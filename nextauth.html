<!DOCTYPE html>
<html>
<body>

<p>
Introduction About NextAuth.js â€‹ NextAuth.js is a complete open-source authentication solution for Next.js applications. It is designed from the ground up to support Next.js and Serverless. Check out the example code to see how easy it is to use NextAuth.js for authentication. Flexible and easy to use â€‹ Designed to work with any OAuth service, it supports OAuth 1.0, 1.0A, 2.0 and OpenID Connect Built-in support for many popular sign-in services Supports email / passwordless authentication Supports stateless authentication with any backend (Active Directory, LDAP, etc) Supports both JSON Web Tokens and database sessions Designed for Serverless but runs anywhere (AWS Lambda, Docker, Heroku, etcâ€¦) Own your own data â€‹ NextAuth.js can be used with or without a database. An open-source solution that allows you to keep control of your data Supports Bring Your Own Database (BYOD) and can be used with any database Built-in support for MySQL, MariaDB, Postgres, SQL Server, MongoDB and SQLite Works great with databases from popular hosting providers Can also be used without a database (e.g. OAuth + JWT) Note: Email sign-in requires a database to be configured to store single-use verification tokens. Secure by default â€‹ Promotes the use of passwordless sign-in mechanisms Designed to be secure by default and encourage best practices for safeguarding user data Uses Cross-Site Request Forgery Tokens on POST routes (sign in, sign out) Default cookie policy aims for the most restrictive policy appropriate for each cookie When JSON Web Tokens are enabled, they are encrypted by default (JWE) with A256GCM Auto-generates symmetric signing and encryption keys for developer convenience Features tab/window syncing and keepalive messages to support short-lived sessions Attempts to implement the latest guidance published by Open Web Application Security Project Advanced options allow you to define your own routines to handle controlling what accounts are allowed to sign in, for encoding and decoding JSON Web Tokens and to set custom cookie security policies and session properties, so you can control who can sign in and how often sessions have to be re-validated. Credits â€‹ NextAuth.js is an open-source project that is only possible thanks to contributors . If you would like to financially support the development of NextAuth.js, you can find more information on our OpenCollective page. Getting Started â€‹ Check out the example code to see how easy it is to use NextAuth.js for authentication.
Getting Started The example code below describes how to add authentication to a Next.js app. New Project â€‹ The easiest way to get started is to clone the example app and follow the instructions in README.md. You can try out a live demo at https://next-auth-example.vercel.app/ Existing Project â€‹ Install NextAuth â€‹ npm yarn pnpm ```npm install next-auth``` ```yarn add next-auth``` ```pnpm add next-auth``` info If you are using TypeScript, NextAuth.js comes with its types definitions within the package. To learn more about TypeScript for ```next-auth``` , check out the TypeScript documentation Add API route â€‹ To add NextAuth.js to a project create a file called ```[...nextauth].js``` in ```pages/api/auth``` . This contains the dynamic route handler for NextAuth.js which will also contain all of your global NextAuth.js configurations. If you're using Next.js 13.2 or above with the new App Router ( ```app/``` ), you can initialize the configuration using the new Route Handlers by following our guide . pages/api/auth/[...nextauth].js ```import NextAuth from "next-auth"import GithubProvider from "next-auth/providers/github"export const authOptions = { // Configure one or more authentication providers providers: [ GithubProvider({ clientId: process.env.GITHUB_ID, clientSecret: process.env.GITHUB_SECRET, }), // ...add more providers here ],}export default NextAuth(authOptions)``` All requests to ```/api/auth/*``` ( ```signIn``` , ```callback``` , ```signOut``` , etc.) will automatically be handled by NextAuth.js. Further Reading : See the options documentation for more details on how to configure providers, databases and other options. Read more about how to add authentication providers here . Configure Shared session state â€‹ To be able to use ```useSession``` first you'll need to expose the session context, ```<SessionProvider />``` , at the top level of your application: pages/_app.jsx ```import { SessionProvider } from "next-auth/react"export default function App({ Component, pageProps: { session, ...pageProps },}) { return ( <SessionProvider session={session}> <Component {...pageProps} /> </SessionProvider> )}``` Instances of ```useSession``` will then have access to the session data and status. The ```<SessionProvider />``` also takes care of keeping the session updated and synced between browser tabs and windows. tip Check out the client documentation to see how you can improve the user experience and page performance by using the NextAuth.js client. Frontend - Add React Hook â€‹ The ```useSession()``` React Hook in the NextAuth.js client is the easiest way to check if someone is signed in. components/login-btn.jsx ```import { useSession, signIn, signOut } from "next-auth/react"export default function Component() { const { data: session } = useSession() if (session) { return ( <> Signed in as {session.user.email} <br /> <button onClick={() => signOut()}>Sign out</button> </> ) } return ( <> Not signed in <br /> <button onClick={() => signIn()}>Sign in</button> </> )}``` You can use the ```useSession``` hook from anywhere in your application (e.g. in a header component). Backend - API Route â€‹ To protect an API Route, you can use the ```getServerSession()``` method. pages/api/restricted.js ```import { getServerSession } from "next-auth/next"import { authOptions } from "./auth/[...nextauth]"export default async (req, res) => { const session = await getServerSession(req, res, authOptions) if (session) { res.send({ content: "This is protected content. You can access this content because you are signed in.", }) } else { res.send({ error: "You must be signed in to view the protected content on this page.", }) }}``` Extensibility â€‹ Using NextAuth.js Callbacks â€‹ NextAuth.js allows you to hook into various parts of the authentication flow via our built-in callbacks . For example, to pass a value from the sign-in to the frontend, client-side, you can use a combination of the ```session``` and ```jwt``` callback like so: pages/api/auth/[...nextauth].js ```...callbacks: { async jwt({ token, account }) { // Persist the OAuth access_token to the token right after signin if (account) { token.accessToken = account.access_token } return token }, async session({ session, token, user }) { // Send properties to the client, like an access_token from a provider. session.accessToken = token.accessToken return session }}...``` Now whenever you call ```getSession``` or ```useSession``` , the data object which is returned will include the ```accessToken``` value. components/accessToken.jsx ```import { useSession, signIn, signOut } from "next-auth/react"export default function Component() { const { data } = useSession() const { accessToken } = data return <div>Access Token: {accessToken}</div>}``` Configuring callback URL (OAuth only) â€‹ If you are using an OAuth provider either through one of our built-in providers or through a custom provider , you'll need to configure a callback URL in your provider's settings. Each provider has a "Configuration" section that should give you pointers on how to do that. Follow these steps to learn how to integrate with an OAuth provider. Deploying to production â€‹ When deploying your site set the ```NEXTAUTH_URL``` environment variable to the canonical URL of the website. ```NEXTAUTH_URL=https://example.com``` tip In production, this needs to be set as an environment variable on the service you use to deploy your app. To set environment variables on Vercel, you can use the dashboard or the ```vercel env pull``` command . For more information please check out our deployment page .
Client API The NextAuth.js client library makes it easy to interact with sessions from React applications. Example Session Object â€‹ ```{ user: { name: string email: string image: string }, expires: Date // This is the expiry of the session, not any of the tokens within the session}``` tip The session data returned to the client does not contain sensitive information such as the Session Token or OAuth tokens. It contains a minimal payload that includes enough data needed to display information on a page about the user who is signed in for presentation purposes (e.g name, email, image). You can use the session callback to customize the session object returned to the client if you need to return additional data in the session object. note The ```expires``` value is rotated, meaning whenever the session is retrieved from the REST API , this value will be updated as well, to avoid session expiry. useSession() â€‹ Client Side: Yes Server Side: No The ```useSession()``` React Hook in the NextAuth.js client is the easiest way to check if someone is signed in. Make sure that ```<SessionProvider>``` is added to ```pages/_app.js``` . Example â€‹ ```import { useSession } from "next-auth/react"export default function Component() { const { data: session, status } = useSession() if (status === "authenticated") { return <p>Signed in as {session.user.email}</p> } return <a href="/api/auth/signin">Sign in</a>}``` ```useSession()``` returns an object containing two values: ```data``` and ```status``` : ```data``` : This can be three values: ```Session``` / ```undefined``` / ```null``` . when the session hasn't been fetched yet, ```data``` will be ```undefined``` in case it failed to retrieve the session, ```data``` will be ```null``` in case of success, ```data``` will be ```Session``` . ```status``` : enum mapping to three possible session states: ```"loading" | "authenticated" | "unauthenticated"``` Require session â€‹ Due to the way Next.js handles ```getServerSideProps``` and ```getInitialProps``` , every protected page load has to make a server-side request to check if the session is valid and then generate the requested page (SSR). This increases server load, and if you are good with making the requests from the client, there is an alternative. You can use ```useSession``` in a way that makes sure you always have a valid session. If after the initial loading state there was no session found, you can define the appropriate action to respond. The default behavior is to redirect the user to the sign-in page, from where - after a successful login - they will be sent back to the page they started on. You can also define an ```onUnauthenticated()``` callback, if you would like to do something else: Example â€‹ pages/protected.jsx ```import { useSession } from "next-auth/react"export default function Admin() { const { status } = useSession({ required: true, onUnauthenticated() { // The user is not authenticated, handle it here. }, }) if (status === "loading") { return "Loading or not authenticated..." } return "User is logged in"}``` Custom Client Session Handling â€‹ Due to the way Next.js handles ```getServerSideProps``` / ```getInitialProps``` , every protected page load has to make a server-side request to check if the session is valid and then generate the requested page. This alternative solution allows for showing a loading state on the initial check and every page transition afterward will be client-side, without having to check with the server and regenerate pages. pages/admin.jsx ```export default function AdminDashboard() { const { data: session } = useSession() // session is always non-null inside this page, all the way down the React tree. return "Some super secret dashboard"}AdminDashboard.auth = true``` pages/_app.jsx ```export default function App({ Component, pageProps: { session, ...pageProps },}) { return ( <SessionProvider session={session}> {Component.auth ? ( <Auth> <Component {...pageProps} /> </Auth> ) : ( <Component {...pageProps} /> )} </SessionProvider> )}function Auth({ children }) { // if `{ required: true }` is supplied, `status` can only be "loading" or "authenticated" const { status } = useSession({ required: true }) if (status === "loading") { return <div>Loading...</div> } return children}``` It can be easily extended/modified to support something like an options object for role based authentication on pages. An example: pages/admin.jsx ```AdminDashboard.auth = { role: "admin", loading: <AdminLoadingSkeleton />, unauthorized: "/login-with-different-user", // redirect to this url}``` Because of how ```_app``` is written, it won't unnecessarily contact the ```/api/auth/session``` endpoint for pages that do not require authentication. More information can be found in the following GitHub Issue . Updating the session â€‹ The ```useSession()``` hook exposes a ```update(data?: any): Promise<Session | null>``` method that can be used to update the session, without reloading the page. You can optionally pass an arbitrary object as the first argument, which will be accessible on the server to merge with the session object. If you are not passing any argument, the session will be reloaded from the server. (This is useful if you want to update the session after a server-side mutation, like updating in the database.) caution The data object is coming from the client, so it needs to be validated on the server before saving. Example â€‹ pages/profile.tsx ```import { useSession } from "next-auth/react"export default function Page() { const { data: session, status, update } = useSession() if (status === "authenticated") { return ( <> <p>Signed in as {session.user.name}</p> {/* Update the value by sending it to the backend. */} <button onClick={() => update({ name: "John Doe" })}> Edit name </button> {/* * Only trigger a session update, assuming you already updated the value server-side. * All `useSession().data` references will be updated. */} <button onClick={() => update()}> Edit name </button> </> ) } return <a href="/api/auth/signin">Sign in</a>}``` Assuming a ```strategy: "jwt"``` is used, the ```update()``` method will trigger a ```jwt``` callback with the ```trigger: "update"``` option. You can use this to update the session object on the server. pages/api/auth/[...nextauth].ts ```...export default NextAuth({ ... callbacks: { // Using the `...rest` parameter to be able to narrow down the type based on `trigger` jwt({ token, trigger, session }) { if (trigger === "update" && session?.name) { // Note, that `session` can be any arbitrary object, remember to validate it! token.name = session } return token } }})``` Assuming a ```strategy: "database"``` is used, the ```update()``` method will trigger the ```session``` callback with the ```trigger: "update"``` option. You can use this to update the session object on the server. pages/api/auth/[...nextauth].ts ```...const adapter = PrismaAdapter(prisma)export default NextAuth({ ... adapter, callbacks: { // Using the `...rest` parameter to be able to narrow down the type based on `trigger` async session({ session, trigger, newSession }) { // Note, that `rest.session` can be any arbitrary object, remember to validate it! if (trigger === "update" && newSession?.name) { // You can update the session in the database if it's not already updated. // await adapter.updateUser(session.user.id, { name: newSession.name }) // Make sure the updated value is reflected on the client session.name = newSession.name } return session } }})``` Refetching the session â€‹ ```SessionProvider#refetchInterval``` and ```SessionProvider#refetchOnWindowFocus``` can be replaced with the ```update()``` method too. note The ```update()``` method won't sync between tabs as the ```refetchInterval``` and ```refetchOnWindowFocus``` options do. pages/profile.tsx ```import {useEffect} from "react"import { useSession } from "next-auth/react"export default function Page() { const { data: session, status, update } = useSession() // Polling the session every 1 hour useEffect(() => { // TIP: You can also use `navigator.onLine` and some extra event handlers // to check if the user is online and only update the session if they are. // https://developer.mozilla.org/en-US/docs/Web/API/Navigator/onLine const interval = setInterval(() => update(), 1000 * 60 * 60) return () => clearInterval(interval) }, [update]) // Listen for when the page is visible, if the user switches tabs // and makes our tab visible again, re-fetch the session useEffect(() => { const visibilityHandler = () => document.visibilityState === "visible" && update() window.addEventListener("visibilitychange", visibilityHandler, false) return () => window.removeEventListener("visibilitychange", visibilityHandler, false) }, [update]) return ( <pre> {JSON.stringify(session, null, 2)} </pre> )}``` getSession() â€‹ Client Side: Yes Server Side: No (See: ```getServerSession()``` NextAuth.js provides a ```getSession()``` helper which should be called client side only to return the current active session. On the server side, this is still available to use , however, we recommend using ```getServerSession``` going forward. The idea behind this is to avoid an additional unnecessary ```fetch``` call on the server side. For more information, please check out this issue . This helper is helpful in case you want to read the session outside of the context of React. When called, ```getSession()``` will send a request to ```/api/auth/session``` and returns a promise with a session object , or ```null``` if no session exists. ```async function myFunction() { const session = await getSession() /* ... */}``` Read the tutorial securing pages and API routes to know how to fetch the session in server side calls using ```getServerSession()``` . getCsrfToken() â€‹ Client Side: Yes Server Side: Yes The ```getCsrfToken()``` method returns the current Cross Site Request Forgery Token (CSRF Token) required to make POST requests (e.g. for signing in and signing out). You likely only need to use this if you are not using the built-in ```signIn()``` and ```signOut()``` methods. Client Side Example â€‹ ```async function myFunction() { const csrfToken = await getCsrfToken() /* ... */}``` Server Side Example â€‹ ```import { getCsrfToken } from "next-auth/react"export default async (req, res) => { const csrfToken = await getCsrfToken({ req }) /* ... */ res.end()}``` getProviders() â€‹ Client Side: Yes Server Side: Yes The ```getProviders()``` method returns the list of providers currently configured for sign in. It calls ```/api/auth/providers``` and returns a list of the currently configured authentication providers. It can be useful if you are creating a dynamic custom sign in page. API Route â€‹ pages/api/example.js ```import { getProviders } from "next-auth/react"export default async (req, res) => { const providers = await getProviders() console.log("Providers", providers) res.end()}``` note Unlike ```getCsrfToken()``` , when calling ```getProviders()``` server side, you don't need to pass anything, just as calling it client side. signIn() â€‹ Client Side: Yes Server Side: No Using the ```signIn()``` method ensures the user ends back on the page they started on after completing a sign in flow. It will also handle CSRF Tokens for you automatically when signing in with email. The ```signIn()``` method can be called from the client in different ways, as shown below. Redirects to sign in page when clicked â€‹ ```import { signIn } from "next-auth/react"export default () => <button onClick={() => signIn()}>Sign in</button>``` Starts OAuth sign-in flow when clicked â€‹ By default, when calling the ```signIn()``` method with no arguments, you will be redirected to the NextAuth.js sign-in page. If you want to skip that and get redirected to your provider's page immediately, call the ```signIn()``` method with the provider's ```id``` . For example to sign in with Google: ```import { signIn } from "next-auth/react"export default () => ( <button onClick={() => signIn("google")}>Sign in with Google</button>)``` Starts Email sign-in flow when clicked â€‹ When using it with the email flow, pass the target ```email``` as an option. ```import { signIn } from "next-auth/react"export default ({ email }) => ( <button onClick={() => signIn("email", { email })}>Sign in with Email</button>)``` Specifying a ```callbackUrl``` â€‹ The ```callbackUrl``` specifies to which URL the user will be redirected after signing in. Defaults to the page URL the sign-in is initiated from. You can specify a different ```callbackUrl``` by specifying it as the second argument of ```signIn()``` . This works for all providers. e.g. ```signIn(undefined, { callbackUrl: '/foo' })``` ```signIn('google', { callbackUrl: 'http://localhost:3000/bar' })``` ```signIn('email', { email, callbackUrl: 'http://localhost:3000/foo' })``` The URL must be considered valid by the redirect callback handler . By default it requires the URL to be an absolute URL at the same host name, or a relative url starting with a slash. If it does not match it will redirect to the homepage. You can define your own redirect callback to allow other URLs. Using the ```redirect: false``` option â€‹ note The redirect option is only available for ```credentials``` and ```email``` providers. In some cases, you might want to deal with the sign in response on the same page and disable the default redirection. For example, if an error occurs (like wrong credentials given by the user), you might want to handle the error on the same page. For that, you can pass ```redirect: false``` in the second parameter object. e.g. ```signIn('credentials', { redirect: false, password: 'password' })``` ```signIn('email', { redirect: false, email: 'bill@fillmurray.com' })``` ```signIn``` will then return a Promise, that resolves to the following: ```{ /** * Will be different error codes, * depending on the type of error. */ error: string | undefined /** * HTTP status code, * hints the kind of error that happened. */ status: number /** * `true` if the signin was successful */ ok: boolean /** * `null` if there was an error, * otherwise the url the user * should have been redirected to. */ url: string | null}``` Additional parameters â€‹ It is also possible to pass additional parameters to the ```/authorize``` endpoint through the third argument of ```signIn()``` . See the Authorization Request OIDC spec for some ideas. (These are not the only possible ones, all parameters will be forwarded) e.g. ```signIn("identity-server4", null, { prompt: "login" })``` always ask the user to re-authenticate ```signIn("auth0", null, { login_hint: "info@example.com" })``` hints the e-mail address to the provider note You can also set these parameters through ```provider.authorizationParams``` . note The following parameters are always overridden server-side: ```redirect_uri``` , ```state``` signOut() â€‹ Client Side: Yes Server Side: No In order to logout, use the ```signOut()``` method to ensure the user ends back on the page they started on after completing the sign out flow. It also handles CSRF tokens for you automatically. It reloads the page in the browser when complete. ```import { signOut } from "next-auth/react"export default () => <button onClick={() => signOut()}>Sign out</button>``` Specifying a ```callbackUrl``` â€‹ As with the ```signIn()``` function, you can specify a ```callbackUrl``` parameter by passing it as an option. e.g. ```signOut({ callbackUrl: 'http://localhost:3000/foo' })``` The URL must be considered valid by the redirect callback handler . By default, it requires the URL to be an absolute URL at the same host name, or you can also supply a relative URL starting with a slash. If it does not match it will redirect to the homepage. You can define your own redirect callback to allow other URLs. Using the ```redirect: false``` option â€‹ If you pass ```redirect: false``` to ```signOut``` , the page will not reload. The session will be deleted, and the ```useSession``` hook is notified, so any indication about the user will be shown as logged out automatically. It can give a very nice experience for the user. tip If you need to redirect to another page but you want to avoid a page reload, you can try: ```const data = await signOut({redirect: false, callbackUrl: "/foo"})``` where ```data.url``` is the validated URL you can redirect the user to without any flicker by using Next.js's ```useRouter().push(data.url)``` SessionProvider â€‹ Using the supplied ```<SessionProvider>``` allows instances of ```useSession()``` to share the session object across components, by using React Context under the hood. It also takes care of keeping the session updated and synced between tabs/windows. pages/_app.js ```import { SessionProvider } from "next-auth/react"export default function App({ Component, pageProps: { session, ...pageProps },}) { return ( <SessionProvider session={session}> <Component {...pageProps} /> </SessionProvider> )}``` If you pass the ```session``` page prop to the ```<SessionProvider>``` â€“ as in the example above â€“ you can avoid checking the session twice on pages that support both server and client side rendering. This only works on pages where you provide the correct ```pageProps``` , however. This is normally done in ```getInitialProps``` or ```getServerSideProps``` on an individual page basis like so: pages/index.js ```import { getServerSession } from "next-auth/next"import { authOptions } from './api/auth/[...nextauth]'...export async function getServerSideProps({ req, res }) { return { props: { session: await getServerSession(req, res, authOptions) } }}``` If every one of your pages needs to be protected, you can do this in ```getInitialProps``` in ```_app``` , otherwise you can do it on a page-by-page basis. Alternatively, you can do per page authentication checks client side, instead of having each authentication check be blocking (SSR) by using the method described below in alternative client session handling . Options â€‹ The session state is automatically synchronized across all open tabs/windows and they are all updated whenever they gain or lose focus or the state changes (e.g. a user signs in or out) when ```refetchOnWindowFocus``` is ```true``` . If you have session expiry times of 30 days (the default) or more then you probably don't need to change any of the default options in the Provider. If you need to, you can trigger an update of the session object across all tabs/windows by calling ```getSession()``` from a client side function. However, if you need to customize the session behavior and/or are using short session expiry times, you can pass options to the provider to customize the behavior of the ```useSession()``` hook. pages/_app.js ```import { SessionProvider } from "next-auth/react"export default function App({ Component, pageProps: { session, ...pageProps },}) { return ( <SessionProvider session={session} // In case you use a custom path and your app lives at "/cool-app" rather than at the root "/" basePath="cool-app" // Re-fetch session every 5 minutes refetchInterval={5 * 60} // Re-fetches session when window is focused refetchOnWindowFocus={true} > <Component {...pageProps} /> </SessionProvider> )}``` note These options have no effect on clients that are not signed in. Every tab/window maintains its own copy of the local session state; the session is not stored in shared storage like localStorage or sessionStorage. Any update in one tab/window triggers a message to other tabs/windows to update their own session state. Using low values for ```refetchInterval``` will increase network traffic and load on authenticated clients and may impact hosting costs and performance. Base path â€‹ If you are using a custom base path, and your application entry point is not at the root of the domain "/" but something else, for example "/my-app/" you can use the ```basePath``` prop to make NextAuth.js aware of that so that all redirects and session handling work as expected. Refetch interval â€‹ See Session Refetching for an alternative option. The ```refetchInterval``` option can be used to contact the server to avoid a session expiring. When ```refetchInterval``` is set to ```0``` (the default) there will be no session polling. If set to any value other than zero, it specifies in seconds how often the client should contact the server to update the session state. If the session state has expired when it is triggered, all open tabs/windows will be updated to reflect this. The value for ```refetchInterval``` should always be lower than the value of the session ```maxAge``` session option . By default, session polling will keep trying, even when the device has no internet access. To circumvent this, you can also set ```refetchWhenOffline``` to ```false``` . This will use ```navigator.onLine``` to only poll when the device is online. Refetch On Window Focus â€‹ See Session Refetching for an alternative option. The ```refetchOnWindowFocus``` option can be used to control whether it automatically updates the session state when you switch a focus on tabs/windows. When ```refetchOnWindowFocus``` is set to ```true``` (the default) tabs/windows will be updated and initialize the components' state when they gain or lose focus. However, if it was set to ```false``` , it stops re-fetching the session and the components will stay as it is. note See the Next.js documentation for more information on _ app.js in Next.js applications. Custom base path â€‹ When your Next.js application uses a custom base path, set the ```NEXTAUTH_URL``` environment variable to the route to the API endpoint in full - as in the example below and as explained here . Also, make sure to pass the ```basePath``` page prop to the ```<SessionProvider>``` â€“ as in the example below â€“ so your custom base path is fully configured and used by NextAuth.js. Example â€‹ In this example, the custom base path used is ```/custom-route``` . ```NEXTAUTH_URL=https://example.com/custom-route/api/auth``` pages/_app.js ```import { SessionProvider } from "next-auth/react"export default function App({ Component, pageProps: { session, ...pageProps },}) { return ( <SessionProvider session={session} basePath="/custom-route/api/auth"> <Component {...pageProps} /> </SessionProvider> )}```
REST API NextAuth.js exposes a REST API that is used by the NextAuth.js client. ```GET``` /api/auth/signin â€‹ Displays the built-in/unbranded sign-in page. ```POST``` /api/auth/signin/:provider â€‹ Starts a provider-specific sign-in flow. The POST submission requires CSRF token from ```/api/auth/csrf``` . In case of an OAuth provider, calling this endpoint will initiate the Authorization Request to your Identity Provider. Learn more about this in the OAuth specification . In case of using the Email provider, calling this endpoint will send a sign-in URL to the user's e-mail address. This endpoint is also used by the ```signIn``` method internally. ```GET``` / ```POST``` /api/auth/callback/:provider â€‹ Handles returning requests from OAuth services during sign-in. For OAuth 2.0 providers that support the ```checks: ["state"]``` option, the state parameter is checked against the one that was generated when the sign in flow was started - this uses a hash of the CSRF token which MUST match for both the ```POST``` and ```GET``` calls during sign-in. Learn more about this in the OAuth specification . ```GET``` /api/auth/signout â€‹ Displays the built-in/unbranded sign out page. ```POST``` /api/auth/signout â€‹ Handles signing the user out - this is a ```POST``` submission to prevent malicious links from triggering signing a user out without their consent. The user session will be invalidated/removed from the cookie/database, depending on the flow you chose to store sessions . The ```POST``` submission requires CSRF token from ```/api/auth/csrf``` . This endpoint is also used by the ```signOut``` method internally. ```GET``` /api/auth/session â€‹ Returns client-safe session object - or an empty object if there is no session. The contents of the session object that is returned are configurable with the ```session``` callback . ```GET``` /api/auth/csrf â€‹ Returns object containing CSRF token. In NextAuth.js, CSRF protection is present on all authentication routes. It uses the "double submit cookie method", which uses a signed HttpOnly, host-only cookie. The CSRF token returned by this endpoint must be passed as form variable named ```csrfToken``` in all ```POST``` submissions to any API endpoint. ```GET``` /api/auth/providers â€‹ Returns a list of configured OAuth services and details (e.g. sign in and callback URLs) for each service. It is useful to dynamically generate custom sign up pages and to check what callback URLs are configured for each OAuth provider that is configured. note The default base path is ```/api/auth``` but it is configurable by specifying a custom path in ```NEXTAUTH_URL``` e.g. ```NEXTAUTH_URL=https://example.com/myapp/api/authentication``` ```/api/auth/signin``` -> ```/myapp/api/authentication/signin```
TypeScript NextAuth.js has its own type definitions to use in your TypeScript projects safely. Even if you don't use TypeScript, IDEs like VSCode will pick this up to provide you with a better developer experience. While you are typing, you will get suggestions about what certain objects/functions look like, and sometimes links to documentation, examples, and other valuable resources. Check out the example repository showcasing how to use ```next-auth``` on a Next.js application with TypeScript: https://github.com/nextauthjs/next-auth-example Adapters â€‹ If you're writing your own custom Adapter, you can take advantage of the types to make sure your implementation conforms to what's expected: ```import type { Adapter } from "next-auth/adapters"function MyAdapter(): Adapter { return { // your adapter methods here }}``` When writing your own custom Adapter in plain JavaScript, note that you can use JSDoc to get helpful editor hints and auto-completion like so: ```/** @return { import("next-auth/adapters").Adapter } */function MyAdapter() { return { // your adapter methods here }}``` note This will work in code editors with a strong TypeScript integration like VSCode or WebStorm. It might not work if you're using more lightweight editors like VIM or Atom. Module Augmentation â€‹ ```next-auth``` comes with certain types/interfaces that are shared across submodules. Good examples are ```Session``` and ```JWT``` . Ideally, you should only need to create these types at a single place, and TS should pick them up in every location where they are referenced. Luckily, Module Augmentation is exactly that, which can do this for us. Define your shared interfaces in a single place, and get type-safety across your application when using ```next-auth``` (or one of its submodules). Main module â€‹ Let's look at ```Session``` : pages/api/auth/[...nextauth].ts ```import NextAuth from "next-auth"export default NextAuth({ callbacks: { session({ session, token, user }) { return session // The return type will match the one returned in `useSession()` }, },})``` pages/index.ts ```import { useSession } from "next-auth/react"export default function IndexPage() { // `session` will match the returned value of `callbacks.session()` from `NextAuth()` const { data: session } = useSession() return ( // Your component )}``` To extend/augment this type, create a ```types/next-auth.d.ts``` file in your project: types/next-auth.d.ts ```import NextAuth from "next-auth"declare module "next-auth" { /** * Returned by `useSession`, `getSession` and received as a prop on the `SessionProvider` React Context */ interface Session { user: { /** The user's postal address. */ address: string } }}``` Extend default interface properties â€‹ By default, TypeScript will merge new interface properties and overwrite existing ones. In this case, the default session user properties will be overwritten, with the new one defined above. If you want to keep the default session user properties, you need to add them back into the newly declared interface: types/next-auth.d.ts ```import NextAuth, { DefaultSession } from "next-auth"declare module "next-auth" { /** * Returned by `useSession`, `getSession` and received as a prop on the `SessionProvider` React Context */ interface Session { user: { /** The user's postal address. */ address: string } & DefaultSession["user"] }}``` Popular interfaces to augment â€‹ Although you can augment almost anything, here are some of the more common interfaces that you might want to override in the ```next-auth``` module: ```/** * The shape of the user object returned in the OAuth providers' `profile` callback, * or the second parameter of the `session` callback, when using a database. */interface User {}/** * Usually contains information about the provider being used * and also extends `TokenSet`, which is different tokens returned by OAuth Providers. */interface Account {}/** The OAuth profile returned from your provider */interface Profile {}``` Make sure that the ```types``` folder is added to ```typeRoots``` in your project's ```tsconfig.json``` file. Submodules â€‹ The ```JWT``` interface can be found in the ```next-auth/jwt``` submodule: types/next-auth.d.ts ```import { JWT } from "next-auth/jwt"declare module "next-auth/jwt" { /** Returned by the `jwt` callback and `getToken`, when using JWT sessions */ interface JWT { /** OpenID ID Token */ idToken?: string }}``` Useful links â€‹ TypeScript documentation: Module Augmentation Digital Ocean: Module Augmentation in TypeScript Contributing â€‹ Contributions of any kind are always welcome, especially for TypeScript. Please keep in mind that we are a small team working on this project in our free time. We will try our best to give support, but if you think you have a solution for a problem, please open a PR! note When contributing to TypeScript, if the actual JavaScript user API does not change in a breaking manner, we reserve the right to push any TypeScript change in a minor release. This ensures that we can keep on a faster release cycle.
Upgrade Guide (v4) NextAuth.js version 4 includes a few breaking changes from the last major version (3.x). So we're here to help you upgrade your applications as smoothly as possible. It should be possible to upgrade from any version of 3.x to the latest 4 release by following the next few migration steps. note Version 4 has been released to GA ðŸš¨ We encourage users to try it out and report any and all issues they come across. You can upgrade to the new version by running: npm yarn pnpm ```npm install next-auth``` ```yarn add next-auth``` ```pnpm add next-auth``` ```next-auth/jwt``` â€‹ We no longer have a default export in ```next-auth/jwt``` . To comply with this, change the following: ```- import jwt from "next-auth/jwt"+ import { getToken } from "next-auth/jwt"``` ```next-auth/react``` â€‹ We've renamed the client-side import source to ```next-auth/react``` . To comply with this change, you will simply have to rename anywhere you were using ```next-auth/client``` . For example: ```- import { useSession } from "next-auth/client"+ import { useSession } from "next-auth/react"``` We've also made the following changes to the names of the exports: ```setOptions``` : Not exposed anymore, use ```SessionProvider``` props ```options``` : Not exposed anymore, use ```SessionProvider``` props ```session``` : Renamed to ```getSession``` ```providers``` : Renamed to ```getProviders``` ```csrfToken``` : Renamed to ```getCsrfToken``` ```signin``` : Renamed to ```signIn``` ```signout``` : Renamed to ```signOut``` ```Provider``` : Renamed to ```SessionProvider``` Introduced in https://github.com/nextauthjs/next-auth/releases/tag/v4.0.0-next.12 ```SessionProvider``` â€‹ Version 4 makes using the ```SessionProvider``` mandatory. This means that you will have to wrap any part of your application using ```useSession``` in this provider, if you were not doing so already. The ```SessionProvider``` has also undergone a few further changes: ```Provider``` is renamed to ```SessionProvider``` The options prop is now flattened as the props of SessionProvider. ```keepAlive``` has been renamed to ```refetchInterval``` . ```clientMaxAge``` has been removed in favor of ```refetchInterval``` , as they overlap in functionality, with the difference that ```refetchInterval``` will keep re-fetching the session periodically in the background. The best practice for wrapping your app in Providers is to do so in your ```pages/_app.jsx``` file. An example use-case with these new changes: ```import { SessionProvider } from "next-auth/react"export default function App({ Component, pageProps: { session, ...pageProps },}) { return ( // `session` comes from `getServerSideProps` or `getInitialProps`. // Avoids flickering/session loading on first load. <SessionProvider session={session} refetchInterval={5 * 60}> <Component {...pageProps} /> </SessionProvider> )}``` Introduced in https://github.com/nextauthjs/next-auth/releases/tag/v4.0.0-next.12 Providers â€‹ Providers now need to be imported individually. ```- import Provider from "next-auth/providers"- Providers.Auth0({...})- Providers.Google({...})+ import Auth0Provider from "next-auth/providers/auth0"+ import GoogleProvider from "next-auth/providers/google"+ Auth0Provider({...})+ GoogleProvider({...})``` The ```AzureADB2C``` provider has been renamed ```AzureAD``` . The ```Basecamp``` provider has been removed, see explanation here . The GitHub provider by default now will not request full write access to user profiles. If you need this scope, please add ```user``` to the scope option manually. The following new options are available when defining your Providers in the configuration: ```authorization``` (replaces ```authorizationUrl``` , ```authorizationParams``` , ```scope``` ) ```token``` replaces ( ```accessTokenUrl``` , ```headers``` , ```params``` ) ```userinfo``` (replaces ```profileUrl``` ) ```issuer``` (replaces ```domain``` ) For more details on their usage, please see options section of the OAuth Provider documentation. When submitting a new OAuth provider to the repository, the ```profile``` callback is expected to only return these fields from now on: ```id``` , ```name``` , ```email``` , and ```image``` . If any of these are missing values, they should be set to ```null``` . Also worth noting is that ```id``` is expected to be returned as a ```string``` type (For example if your provider returns it as a number, you can cast it by using the ```.toString()``` method). This makes the returned profile object comply across all providers/accounts/adapters, and hopefully cause less confusion in the future. Implemented in: #2411 Introduced in https://github.com/nextauthjs/next-auth/releases/tag/v4.0.0-next.20 ```useSession``` Hook â€‹ The ```useSession``` hook has been updated to return an object. This allows you to test states much more cleanly with the new ```status``` option. ```- const [ session, loading ] = useSession()+ const { data: session, status } = useSession()+ const loading = status === "loading"``` Check the docs for the possible values of both ```session.status``` and ```session.data``` . Introduced in https://github.com/nextauthjs/next-auth/releases/tag/v4.0.0-next.18 Named Parameters â€‹ We have changed the arguments to our callbacks to the named parameters pattern. This way you don't have to use dummy ```_``` placeholders or other tricks. Callbacks â€‹ The signatures for the callback methods now look like this: ```- signIn(user, account, profileOrEmailOrCredentials)+ signIn({ user, account, profile, email, credentials })``` ```- redirect(url, baseUrl)+ redirect({ url, baseUrl })``` ```- session(session, tokenOrUser)+ session({ session, token, user })``` ```- jwt(token, user, account, OAuthProfile, isNewUser)+ jwt({ token, user, account, profile, isNewUser })``` Introduced in https://github.com/nextauthjs/next-auth/releases/tag/v4.0.0-next.17 Events â€‹ Two event signatures have changed to also use the named parameters pattern, ```signOut``` and ```updateUser``` . ```// [...nextauth].js...events: {- signOut(tokenOrSession),+ signOut({ token, session }), // token if using JWT, session if DB persisted sessions.- updateUser(user)+ updateUser({ user })}``` Introduced in https://github.com/nextauthjs/next-auth/releases/tag/v4.0.0-next.20 JWT configuration â€‹ We have removed some of the configuration options when using JSON Web Tokens, here's the PR for more context. ```export default NextAuth({ // ... jwt: { secret, maxAge,- encryptionKey- signingKey- encryptionKey- verificationOptions encode({ token secret maxAge- signingKey- signingOptions- encryptionKey- encryptionOptions- encryption }) {}, decode({ token secret- maxAge- signingKey- verificationKey- verificationOptions- encryptionKey- decryptionKey- decryptionOptions- encryption }) {} }})``` Logger API â€‹ The logger API has been simplified to use at most two parameters, where the second is usually an object ( ```metadata``` ) containing an ```error``` object. If you are not using the logger settings you can ignore this change. ```// [...nextauth.js]import log from "some-logger-service"...logger: {- error(code, ...message) {},+ error(code, metadata) {},- warn(code, ...message) {},+ warn(code) {}- debug(code, ...message) {}+ debug(code, metadata) {}}``` Introduced in https://github.com/nextauthjs/next-auth/releases/tag/v4.0.0-next.19 ```nodemailer``` â€‹ Like ```typeorm``` and ```prisma``` , ```nodemailer``` is no longer included as a dependency by default. If you are using the Email provider you must install it in your project manually, or use any other Email library in the ```sendVerificationRequest``` callback. This reduces bundle size for those not actually using the Email provider. Remember, when using the Email provider, it is mandatory to also use a database adapter due to the fact that verification tokens need to be persisted longer term for the magic link functionality to work. Introduced in https://github.com/nextauthjs/next-auth/releases/tag/v4.0.0-next.2 Theme â€‹ We have added some basic customization options to our built-in pages like ```signin``` , ```signout``` , etc. These can be set under the ```theme``` configuration key. This used to be a string which only controlled the color scheme option. Now it is an object with the following options: ```theme: { colorScheme: "auto", // "auto" | "dark" | "light" brandColor: "", // Hex color value logo: "" // Absolute URL to logo image}``` The hope is that with some minimal configuration / customization options, users won't immediately feel the need to replace the built-in pages with their own. More details and screenshots of the new theme options can be found under configuration/pages . Introduced in #2788 Session â€‹ The ```session.jwt: boolean``` option has been renamed to ```session.strategy: "jwt" | "database"``` . The goal is to make the user's options more intuitive: No adapter, ```strategy: "jwt"``` : This is the default. The session is saved in a cookie and never persisted anywhere. With Adapter, ```strategy: "database"``` : If an Adapter is defined, this will be the implicit setting. No user config is needed. With Adapter, ```strategy: "jwt"``` : The user can explicitly instruct ```next-auth``` to use JWT even if a database is available. This can result in faster lookups in compromise of lowered security. Read more about: https://next-auth.js.org/faq#json-web-tokens Example: ```session: {- jwt: true,+ strategy: "jwt",}``` Introduced in #3144 Adapters â€‹ Most importantly, the core ```next-auth``` package no longer ships with ```typeorm``` or any other database adapter by default. This brings the default bundle size down significantly for those not needing to persist user data to a database. You can find the official Adapters in the ```packages``` directory in the primary monorepo ( nextauthjs/next-auth ). Although you can still create your own with a new, simplified Adapter API . If you have a database that was created with a ```3.x.x``` or earlier version of NextAuth.js, you will need to run a migration to update the schema to the new version 4 database model. See the bottom of this migration guide for database specific migration examples. If you use the built-in TypeORM or Prisma adapters, these have been removed from the core ```next-auth``` package. Thankfully the migration is easy; you just need to install the external packages for your database and change the import in your ```[...nextauth].js``` . The ```database``` option has been removed, you must now do the following instead: ```// [...nextauth].jsimport NextAuth from "next-auth"+ import { TypeORMLegacyAdapter } from "@next-auth/typeorm-legacy-adapter"...export default NextAuth({- database: "yourconnectionstring",+ adapter: TypeORMLegacyAdapter("yourconnectionstring")})``` The ```prisma-legacy``` adapter has been removed, please use the ```@next-auth/prisma-adapter``` instead. The ```typeorm-legacy``` adapter has been upgraded to use the newer adapter API, but has retained the ```typeorm-legacy``` name. We aim to migrate this to individual lighter weight adapters for each database type in the future, or switch out ```typeorm``` . MongoDB has been moved to its own adapter under ```@next-auth/mongodb-adapter``` . See the MongoDB Adapter docs . Introduced in https://github.com/nextauthjs/next-auth/releases/tag/v4.0.0-next.8 and #2361 Adapter API â€‹ This does not require any changes from the user - these are adapter specific changes only The Adapter API has been rewritten and significantly simplified in NextAuth.js v4. The adapters now have less work to do as some functionality has been migrated to the core of NextAuth, like hashing the verification token . If you are an adapter maintainer or are interested in writing your own adapter, you can find more information about this change in #2361 and release https://github.com/nextauthjs/next-auth/releases/tag/v4.0.0-next.22 . Schema changes â€‹ The way we save data with adapters have slightly changed. With the new Adapter API, we wanted to make it easier to extend your database with additional fields. For example if your User needs an extra ```phone``` field, it should be enough to add that to your database's schema, and no changes will be necessary in your adapter. ```created_at``` / ```createdAt``` and ```updated_at``` / ```updatedAt``` fields are removed from all Models. ```user_id``` / ```userId``` consistently named ```userId``` . ```compound_id``` / ```compoundId``` is removed from Account. ```access_token``` / ```accessToken``` is removed from Session. ```email_verified``` / ```emailVerified``` on User is consistently named ```emailVerified``` . ```provider_id``` / ```providerId``` renamed to ```provider``` on Account ```provider_type``` / ```providerType``` renamed to ```type``` on Account ```provider_account_id``` / ```providerAccountId``` on Account is consistently named ```providerAccountId``` ```access_token_expires``` / ```accessTokenExpires``` on Account renamed to ```expires_at``` New fields on Account: ```token_type``` , ```scope``` , ```id_token``` , ```session_state``` ```verification_requests``` table has been renamed to ```verification_tokens``` See the changes ```User { id name email- emailVerified+ email_verified image- created_at- updated_at}Account { id- compound_id- user_id+ userId- provider_type+ type- provider_id+ provider- provider_account_id+ providerAccountId refresh_token access_token- access_token_expires+ expires_in+ expires_at+ token_type+ scope+ id_token+ session_state- created_at- updated_at}Session { id userId expires sessionToken- access_token- created_at- updated_at}VerificationToken { id token expires identifier- created_at- updated_at}``` For more info, see the Models page . Database migration â€‹ NextAuth.js v4 has a slightly different database schema compared to v3. If you're using any of our adapters and want to upgrade, you can use on of the below schemas. They are designed to be run directly against the database itself. So instead of having one in Prisma syntax, one in TypeORM syntax, etc. we've decided to just make one for each underlying database type. i.e. one for Postgres, one for MySQL, one for MongoDB, etc. MySQL â€‹ ```/* ACCOUNT */ALTER TABLE accountsCHANGE "access_token_expires" "expires_at" intCHANGE "user_id" "userId" varchar(255)ADD CONSTRAINT fk_user_id FOREIGN KEY (userId) REFERENCES users(id)RENAME COLUMN "provider_id" "provider"RENAME COLUMN "provider_account_id" "providerAccountId"DROP COLUMN "provider_type"DROP COLUMN "compound_id"/* The following two timestamp columns have never been necessary for NextAuth.js to function, but can be kept if you want */DROP COLUMN "created_at"DROP COLUMN "updated_at"ADD COLUMN "token_type" varchar(255) NULLADD COLUMN "scope" varchar(255) NULLADD COLUMN "id_token" varchar(255) NULLADD COLUMN "session_state" varchar(255) NULL/* Note: These are only needed if you're going to be using the old Twitter OAuth 1.0 provider. */ADD COLUMN "oauth_token_secret" varchar(255) NULLADD COLUMN "oauth_token" varchar(255) NULL/* USER */ALTER TABLE usersRENAME COLUMN "email_verified" "emailVerified"/* The following two timestamp columns have never been necessary for NextAuth.js to function, but can be kept if you want */DROP COLUMN "created_at"DROP COLUMN "updated_at"/* SESSION */ALTER TABLE sessionsRENAME COLUMN "session_token" "sessionToken"CHANGE "user_id" "userId" varchar(255)ADD CONSTRAINT fk_user_id FOREIGN KEY (userId) REFERENCES users(id)DROP COLUMN "access_token"/* The following two timestamp columns have never been necessary for NextAuth.js to function, but can be kept if you want */DROP COLUMN "created_at"DROP COLUMN "updated_at"/* VERIFICATION REQUESTS */ALTER TABLE verification_requests RENAME verification_tokensALTER TABLE verification_tokensDROP COLUMN id/* The following two timestamp columns have never been necessary for NextAuth.js to function, but can be kept if you want */DROP COLUMN "created_at"DROP COLUMN "updated_at"``` Postgres â€‹ ```/* ACCOUNT */ALTER TABLE accounts RENAME COLUMN "user_id" TO "userId";ALTER TABLE accounts RENAME COLUMN "provider_id" TO "provider";ALTER TABLE accounts RENAME COLUMN "provider_account_id" TO "providerAccountId";ALTER TABLE accounts RENAME COLUMN "access_token_expires" TO "expires_at";ALTER TABLE accounts RENAME COLUMN "provider_type" TO "type";/* Do conversion of TIMESTAMPTZ to BIGINT */ALTER TABLE accounts ALTER COLUMN "expires_at" TYPE TEXT USING CAST(extract(epoch FROM "expires_at") AS BIGINT)*1000;/* Keep id as SERIAL with autoincrement when using ORM. Using new v4 uuid format won't work because of incompatibility *//* ALTER TABLE accounts ALTER COLUMN "id" TYPE TEXT; *//* ALTER TABLE accounts ALTER COLUMN "userId" TYPE TEXT; */ALTER TABLE accounts ALTER COLUMN "type" TYPE TEXT;ALTER TABLE accounts ALTER COLUMN "provider" TYPE TEXT;ALTER TABLE accounts ALTER COLUMN "providerAccountId" TYPE TEXT;ALTER TABLE accounts ADD CONSTRAINT fk_user_id FOREIGN KEY ("userId") REFERENCES users(id);ALTER TABLE accountsDROP COLUMN IF EXISTS "compound_id";/* The following two timestamp columns have never been necessary for NextAuth.js to function, but can be kept if you want */ALTER TABLE accountsDROP COLUMN IF EXISTS "created_at",DROP COLUMN IF EXISTS "updated_at";ALTER TABLE accountsADD COLUMN IF NOT EXISTS "token_type" TEXT NULL,ADD COLUMN IF NOT EXISTS "scope" TEXT NULL,ADD COLUMN IF NOT EXISTS "id_token" TEXT NULL,ADD COLUMN IF NOT EXISTS "session_state" TEXT NULL;/* Note: These are only needed if you're going to be using the old Twitter OAuth 1.0 provider. *//* ALTER TABLE accountsADD COLUMN IF NOT EXISTS "oauth_token_secret" TEXT NULL,ADD COLUMN IF NOT EXISTS "oauth_token" TEXT NULL; *//* USER */ALTER TABLE users RENAME COLUMN "email_verified" TO "emailVerified";/* Keep id as SERIAL with autoincrement when using ORM. Using new v4 uuid format won't work because of incompatibility *//* ALTER TABLE users ALTER COLUMN "id" TYPE TEXT; */ALTER TABLE users ALTER COLUMN "name" TYPE TEXT;ALTER TABLE users ALTER COLUMN "email" TYPE TEXT;ALTER TABLE users ALTER COLUMN "image" TYPE TEXT;/* Do conversion of TIMESTAMPTZ to BIGINT and then TEXT */ALTER TABLE users ALTER COLUMN "emailVerified" TYPE TEXT USING CAST(CAST(extract(epoch FROM "emailVerified") AS BIGINT)*1000 AS TEXT);/* The following two timestamp columns have never been necessary for NextAuth.js to function, but can be kept if you want */ALTER TABLE usersDROP COLUMN IF EXISTS "created_at",DROP COLUMN IF EXISTS "updated_at";/* SESSION */ALTER TABLE sessions RENAME COLUMN "session_token" TO "sessionToken";ALTER TABLE sessions RENAME COLUMN "user_id" TO "userId";/* Keep id as SERIAL with autoincrement when using ORM. Using new v4 uuid format won't work because of incompatibility *//* ALTER TABLE sessions ALTER COLUMN "id" TYPE TEXT; *//* ALTER TABLE sessions ALTER COLUMN "userId" TYPE TEXT; */ALTER TABLE sessions ALTER COLUMN "sessionToken" TYPE TEXT;ALTER TABLE sessions ADD CONSTRAINT fk_user_id FOREIGN KEY ("userId") REFERENCES users(id);/* Do conversion of TIMESTAMPTZ to BIGINT and then TEXT */ALTER TABLE sessions ALTER COLUMN "expires" TYPE TEXT USING CAST(CAST(extract(epoch FROM "expires") AS BIGINT)*1000 AS TEXT);ALTER TABLE sessions DROP COLUMN IF EXISTS "access_token";/* The following two timestamp columns have never been necessary for NextAuth.js to function, but can be kept if you want */ALTER TABLE sessionsDROP COLUMN IF EXISTS "created_at",DROP COLUMN IF EXISTS "updated_at";/* VERIFICATION REQUESTS */ALTER TABLE verification_requests RENAME TO verification_tokens;/* Keep id as ORM needs it *//* ALTER TABLE verification_tokens DROP COLUMN IF EXISTS id; */ALTER TABLE verification_tokens ALTER COLUMN "identifier" TYPE TEXT;ALTER TABLE verification_tokens ALTER COLUMN "token" TYPE TEXT;/* Do conversion of TIMESTAMPTZ to BIGINT and then TEXT */ALTER TABLE verification_tokens ALTER COLUMN "expires" TYPE TEXT USING CAST(CAST(extract(epoch FROM "expires") AS BIGINT)*1000 AS TEXT);/* The following two timestamp columns have never been necessary for NextAuth.js to function, but can be kept if you want */ALTER TABLE verification_tokensDROP COLUMN IF EXISTS "created_at",DROP COLUMN IF EXISTS "updated_at";``` MongoDB â€‹ MongoDB is a document database and as such new fields will be automatically populated. You do, however, need to update the names of existing fields which are going to be reused. ```db.getCollection('accounts').updateMany({}, { $rename: { "provider_id": "provider", "provider_account_id": "providerAccountId", "user_id": "userId", "access_token_expires": "expires_at" }})db.getCollection('users').updateMany({}, { $rename: { "email_verified": "emailVerified" }})db.getCollection('sessions').updateMany({}, { $rename: { "session_token": "sessionToken", "user_id": "userId" }})``` Missing ```secret``` â€‹ NextAuth.js used to generate a secret for convenience, when the user did not define one. This might have been useful in development, but can be a concern in production. We have always been clear about that in the docs, but from now on, if you forget to define a ```secret``` property in production, we will show the user an error page. Read more about this option here You can generate a secret to be placed in the ```secret``` configuration option via the following command: ```$ openssl rand -base64 32``` Therefore, your NextAuth.js config should look something like this: /pages/api/auth/[...nextauth].js ```...export default NextAuth({ ... providers: [...], secret: "LlKq6ZtYbr+hTC073mAmAh9/h2HwMfsFo4hrfCx5mLg=", ...})``` Introduced in #3143 Session ```strategy``` â€‹ We have always supported two different session strategies. The first being our most popular and default strategy - the JWT based one. The second is the database adapter persisted session strategy. Both have their advantages/disadvantages, you can learn more about them on the FAQ page. Previously, the way you configured this was through the ```jwt: boolean``` flag in the ```session``` option. The names ```session``` and ```jwt``` might have been a bit overused in the options, and so for a clearer message, we renamed this option to ```strategy: "jwt" | "database"``` , it is still in the ```session``` object. This will hopefully better indicate the purpose of this option as well as make very explicit which type of session you are going to use. See the ```session``` option docs for more details. Introduced in #3144 Summary â€‹ We hope this migration goes smoothly for each and every one of you! If you have any questions or get stuck anywhere, feel free to create a new issue on GitHub.
Initialization The main entry point of NextAuth.js is the ```NextAuth``` method that you import from ```next-auth``` . It handles different types of requests, as defined in the REST API section. info NextAuth.js cannot use the run Edge Runtime for initialization. The upcoming ```@auth/nextjs``` library (which will replace ```next-auth``` ) on the other hand will be fully compatible. You can initialize NextAuth.js in a few different ways. Simple initialization â€‹ API Routes ( ```pages``` ) â€‹ In Next.js, you can define an API route that will catch all requests that begin with a certain path. Conveniently, this is called Catch all API routes . When you define a ```/pages/api/auth/[...nextauth]``` JS/TS file, you instruct NextAuth.js that every API request beginning with ```/api/auth/*``` should be handled by the code written in the ```[...nextauth]``` file. /pages/api/auth/[...nextauth].ts ```import NextAuth from "next-auth"export default NextAuth({ ...})``` Here, you only need to pass your options to ```NextAuth``` , and ```NextAuth``` does the rest. This is the preferred initialization in tutorials/other parts of the documentation, as it simplifies the code and reduces potential errors in the authentication flow. Route Handlers ( ```app/``` ) â€‹ Next.js 13.2 introduced Route Handlers , the preferred way to handle REST-like requests in App Router ( ```app/``` ). You can initialize NextAuth.js with a Route Handler too, very similar to API Routes. /app/api/auth/[...nextauth]/route.ts ```import NextAuth from "next-auth"const handler = NextAuth({ ...})export { handler as GET, handler as POST }``` Internally, NextAuth.js detects that it is being initialized in a Route Handler (by understanding that it is passed a Web ```Request``` instance ), and will return a handler that returns a ```Response``` instance . A Route Handler file expects you to export some named handler functions that handle a request and return a response. NextAuth.js needs the ```GET``` and ```POST``` handlers to function properly, so we export those two. info Technically, in a Route Handler, the ```api/``` prefix is not necessary, but we decided to keep it required for an easier migration. Advanced initialization â€‹ info The following describes the advanced initialization with API Routes, but everything will apply similarily when using Route Handlers too. Instead, ```NextAuth``` will receive the first two arguments of a Route Handler, and the third argument will be the auth options If you have a specific use case and need to make NextAuth.js do something slightly different than what it is designed for, keep in mind, the ```[...nextauth].ts``` config file is just a regular API Route . That said, you can initialize NextAuth.js like this: /pages/api/auth/[...nextauth].ts ```import type { NextApiRequest, NextApiResponse } from "next"import NextAuth from "next-auth"export default async function auth(req: NextApiRequest, res: NextApiResponse) { // Do whatever you want here, before the request is passed down to `NextAuth` return await NextAuth(req, res, { ... })}``` The ```...``` section will still be your options , but you now have the possibility to execute/modify certain things on the request. You could for example log the request, add headers, read ```query``` or ```body``` parameters, whatever you would do in an API route. tip Since this is a catch-all route, remember to check what kind of NextAuth.js "action" is running. Compare the REST API with the ```req.query.nextauth``` parameter. For example to execute something on the "callback" action when the request is a POST method, you can check for ```req.query.nextauth.includes("callback") && req.method === "POST"``` note ```NextAuth``` will implicitly close the response (by calling ```res.end``` , ```res.send``` or similar), so you should not run code after ```NextAuth``` in the function body. Using ```return NextAuth``` makes sure you don't forget that. Any variable you create this way will be available in the ```NextAuth``` options as well, since they are in the same scope. /pages/api/auth/[...nextauth].ts ```import type { NextApiRequest, NextApiResponse } from "next"import NextAuth from "next-auth"export default async function auth(req: NextApiRequest, res: NextApiResponse) { if(req.query.nextauth.includes("callback") && req.method === "POST") { console.log( "Handling callback request from my Identity Provider", req.body ) } // Get a custom cookie value from the request const someCookie = req.cookies["some-custom-cookie"] return await NextAuth(req, res, { ... callbacks: { session({ session, token }) { // Return a cookie value as part of the session // This is read when `req.query.nextauth.includes("session") && req.method === "GET"` session.someCookie = someCookie return session } } })}``` A practical example could be to not show a certain provider on the default sign-in page, but still be able to sign in with it. (The idea is taken from this discussion ): /pages/api/auth/[...nextauth].ts ```import NextAuth from "next-auth"import CredentialsProvider from "next-auth/providers/credentials"import GoogleProvider from "next-auth/providers/google"export default async function auth(req, res) { const providers = [ CredentialsProvider(...), GoogleProvider(...), ] const isDefaultSigninPage = req.method === "GET" && req.query.nextauth.includes("signin") // Will hide the `GoogleProvider` when you visit `/api/auth/signin` if (isDefaultSigninPage) providers.pop() return await NextAuth(req, res, { providers, ... })}``` For more details on all available actions and which methods are supported, please check out the REST API documentation or the appropriate area in the source code This way of initializing ```NextAuth``` is very powerful, but should be used sparingly. danger Changing parts of the request that is essential to ```NextAuth``` to do it's job - like messing with the default cookies - can have unforeseen consequences, and have the potential to introduce security holes if done incorrectly. Only change those if you understand consequences.
Options Environment Variables â€‹ NEXTAUTH_URL â€‹ When deploying to production, set the ```NEXTAUTH_URL``` environment variable to the canonical URL of your site. ```NEXTAUTH_URL=https://example.com``` If your Next.js application uses a custom base path, specify the route to the API endpoint in full. More information about the usage of custom base path here . e.g. ```NEXTAUTH_URL=https://example.com/custom-route/api/auth``` tip When you're using a custom base path, you will need to pass the ```basePath``` page prop to the ```<SessionProvider>``` . More information here . note Using System Environment Variables we automatically detect when you deploy to Vercel so you don't have to define this variable. Make sure Automatically expose System Environment Variables is checked in your Project Settings. NEXTAUTH_SECRET â€‹ Used to encrypt the NextAuth.js JWT, and to hash email verification tokens . This is the default value for the ```secret``` option in NextAuth and Middleware . NEXTAUTH_URL_INTERNAL â€‹ If provided, server-side calls will use this instead of ```NEXTAUTH_URL``` . Useful in environments when the server doesn't have access to the canonical URL of your site. Defaults to ```NEXTAUTH_URL``` . ```NEXTAUTH_URL_INTERNAL=http://10.240.8.16``` Options â€‹ Options are passed to NextAuth.js when initializing it in an API route. providers â€‹ Default value : ```[]``` Required : Yes Description â€‹ An array of authentication providers for signing in (e.g. Google, Facebook, Twitter, GitHub, Email, etc) in any order. This can be one of the built-in providers or an object with a custom provider. See the providers documentation for a list of supported providers and how to use them. secret â€‹ Default value : ```string``` ( SHA hash of the "options" object ) in development, no default in production. Required : Yes, in production! Description â€‹ A random string is used to hash tokens, sign/encrypt cookies and generate cryptographic keys. If you set ```NEXTAUTH_SECRET``` as an environment variable, you don't have to define this option. If no value is specified in development (and there is no ```NEXTAUTH_SECRET``` variable either), it uses a hash for all configuration options, including OAuth Client ID / Secrets for entropy. danger Not providing any ```secret``` or ```NEXTAUTH_SECRET``` will throw an error in production. You can quickly create a good value on the command line via this ```openssl``` command. ```$ openssl rand -base64 32``` tip If you rely on the default secret generation in development, you might notice JWT decryption errors, since the secret changes whenever you change your configuration. Defining an explicit secret will make this problem go away. We will likely make this option mandatory, even in development, in the future. session â€‹ Default value : ```object``` Required : No Description â€‹ The ```session``` object and all properties on it are optional. Default values for this option are shown below: ```session: { // Choose how you want to save the user session. // The default is `"jwt"`, an encrypted JWT (JWE) stored in the session cookie. // If you use an `adapter` however, we default it to `"database"` instead. // You can still force a JWT session by explicitly defining `"jwt"`. // When using `"database"`, the session cookie will only contain a `sessionToken` value, // which is used to look up the session in the database. strategy: "database", // Seconds - How long until an idle session expires and is no longer valid. maxAge: 30 * 24 * 60 * 60, // 30 days // Seconds - Throttle how frequently to write to database to extend a session. // Use it to limit write operations. Set to 0 to always update the database. // Note: This option is ignored if using JSON Web Tokens updateAge: 24 * 60 * 60, // 24 hours // The session token is usually either a random UUID or string, however if you // need a more customized session token string, you can define your own generate function. generateSessionToken: () => { return randomUUID?.() ?? randomBytes(32).toString("hex") }}``` jwt â€‹ Default value : ```object``` Required : No Description â€‹ JSON Web Tokens can be used for session tokens if enabled with ```session: { strategy: "jwt" }``` option. JSON Web Tokens are enabled by default if you have not specified an adapter. JSON Web Tokens are encrypted (JWE) by default. We recommend you keep this behaviour. See the Override JWT ```encode``` and ```decode``` methods advanced option. JSON Web Token Options â€‹ ```jwt: { // The maximum age of the NextAuth.js issued JWT in seconds. // Defaults to `session.maxAge`. maxAge: 60 * 60 * 24 * 30, // You can define your own encode/decode functions for signing and encryption async encode() {}, async decode() {},}``` An example JSON Web Token contains a payload like this: ```{ name: 'Iain Collins', email: 'me@iaincollins.com', picture: 'https://example.com/image.jpg', iat: 1594601838, exp: 1597193838}``` JWT Helper â€‹ You can use the built-in ```getToken()``` helper method to verify and decrypt the token, like this: ```import { getToken } from "next-auth/jwt"const secret = process.env.NEXTAUTH_SECRETexport default async function handler(req, res) { // if using `NEXTAUTH_SECRET` env variable, we detect it, and you won't actually need to `secret` // const token = await getToken({ req }) const token = await getToken({ req, secret }) console.log("JSON Web Token", token) res.end()}``` For convenience, this helper function is also able to read and decode tokens passed from the ```Authorization: 'Bearer token'``` HTTP header. Required The getToken() helper requires the following options: ```req``` - (object) Request object ```secret``` - (string) JWT Secret. Use ```NEXTAUTH_SECRET``` instead. You must also pass any options configured on the ```jwt``` option to the helper. e.g. Including custom session ```maxAge``` and custom signing and/or encryption keys or options Optional It also supports the following options: ```secureCookie``` - (boolean) Use secure prefixed cookie name By default, the helper function will attempt to determine if it should use the secure prefixed cookie (e.g. ```true``` in production and ```false``` in development, unless NEXTAUTH_URL contains an HTTPS URL). ```cookieName``` - (string) Session token cookie name The ```secureCookie``` option is ignored if ```cookieName``` is explicitly specified. ```raw``` - (boolean) Get raw token (not decoded) If set to ```true``` returns the raw token without decrypting or verifying it. note The JWT is stored in the Session Token cookie, the same cookie used for tokens with database sessions. pages â€‹ Default value : ```{}``` Required : No Description â€‹ Specify URLs to be used if you want to create custom sign in, sign out and error pages. Pages specified will override the corresponding built-in page. For example: ```pages: { signIn: '/auth/signin', signOut: '/auth/signout', error: '/auth/error', // Error code passed in query string as ?error= verifyRequest: '/auth/verify-request', // (used for check email message) newUser: '/auth/new-user' // New users will be directed here on first sign in (leave the property out if not of interest)}``` note When using this configuration, ensure that these pages actually exist. For example ```error: '/auth/error'``` refers to a page file at ```pages/auth/error.js``` . See the documentation for the pages option for more information. callbacks â€‹ Default value : ```object``` Required : No Description â€‹ Callbacks are asynchronous functions you can use to control what happens when an action is performed. Callbacks are extremely powerful, especially in scenarios involving JSON Web Tokens as they allow you to implement access controls without a database and to integrate with external databases or APIs. You can specify a handler for any of the callbacks below. ```callbacks: { async signIn({ user, account, profile, email, credentials }) { return true }, async redirect({ url, baseUrl }) { return baseUrl }, async session({ session, token, user }) { return session }, async jwt({ token, user, account, profile, isNewUser }) { return token }}``` See the callbacks documentation for more information on how to use the callback functions. events â€‹ Default value : ```object``` Required : No Description â€‹ Events are asynchronous functions that do not return a response, they are useful for audit logging. You can specify a handler for any of these events below - e.g. for debugging or to create an audit log. The content of the message object varies depending on the flow (e.g. OAuth or Email authentication flow, JWT or database sessions, etc). See the events documentation for more information on the form of each message object and how to use the events functions. ```events: { async signIn(message) { /* on successful sign in */ }, async signOut(message) { /* on signout */ }, async createUser(message) { /* user created */ }, async updateUser(message) { /* user updated - e.g. their email was verified */ }, async linkAccount(message) { /* account (e.g. Twitter) linked to a user */ }, async session(message) { /* session is active */ },}``` adapter â€‹ Default value : none Required : No Description â€‹ By default NextAuth.js does not include an adapter any longer. If you would like to persist user / account data, please install one of the many available adapters. More information can be found in the adapter documentation . debug â€‹ Default value : ```false``` Required : No Description â€‹ Set debug to ```true``` to enable debug messages for authentication and database operations. logger â€‹ Default value : ```console``` Required : No Description â€‹ Override any of the logger levels ( ```undefined``` levels will use the built-in logger), and intercept logs in NextAuth.js. You can use this to send NextAuth.js logs to a third-party logging service. The ```code``` parameter for ```error``` and ```warn``` are explained in the Warnings and Errors pages respectively. Example: /pages/api/auth/[...nextauth].js ```import log from "logging-service"export default NextAuth({ ... logger: { error(code, metadata) { log.error(code, metadata) }, warn(code) { log.warn(code) }, debug(code, metadata) { log.debug(code, metadata) } } ...})``` note If the ```debug``` level is defined by the user, it will be called regardless of the ```debug: false``` option . theme â€‹ Default value : ```object``` Required : No Description â€‹ Changes the color scheme theme of pages as well as allows some minor customization. Set ```theme.colorScheme``` to ```"light"``` , if you want to force pages to always be light. Set to ```"dark"``` , if you want to force pages to always be dark. Set to ```"auto"``` , (or leave this option out) if you want the pages to follow the preferred system theme. (Uses the prefers-color-scheme media query.) In addition, you can define a logo URL in ```theme.logo``` which will be rendered above the main card in the default signin/signout/error/verify-request pages, as well as a ```theme.brandColor``` which will affect the accent color of these pages. The sign-in button's background color will match the ```brandColor``` and defaults to ```"#346df1"``` . The text color is ```#fff``` by default, but if your brand color gives a weak contrast, correct it with the ```buttonText``` color option. ```theme: { colorScheme: "auto", // "auto" | "dark" | "light" brandColor: "", // Hex color code logo: "", // Absolute URL to image buttonText: "" // Hex color code}``` Advanced Options â€‹ Advanced options are passed the same way as basic options, but may have complex implications or side effects. You should try to avoid using advanced options unless you are very comfortable using them. useSecureCookies â€‹ Default value : ```true``` for HTTPS sites / ```false``` for HTTP sites Required : No Description â€‹ When set to ```true``` (the default for all site URLs that start with ```https://``` ) then all cookies set by NextAuth.js will only be accessible from HTTPS URLs. This option defaults to ```false``` on URLs that start with ```http://``` (e.g. ```http://localhost:3000``` ) for developer convenience. note Properties on any custom ```cookies``` that are specified override this option. danger Setting this option to false in production is a security risk and may allow sessions to be hijacked if used in production. It is intended to support development and testing. Using this option is not recommended. cookies â€‹ Default value : ```{}``` Required : No Description â€‹ Cookies in NextAuth.js are chunked by default, meaning that once they reach the 4kb limit, we will create a new cookie with the ```.{number}``` suffix and reassemble the cookies in the correct order when parsing / reading them. This was introduced to avoid size constraints which can occur when users want to store additional data in their sessionToken, for example. You can override the default cookie names and options for any of the cookies used by NextAuth.js. This is an advanced option and using it is not recommended as you may break authentication or introduce security flaws into your application. You can specify one or more cookies with custom properties, but if you specify custom options for a cookie you must provide all the options for that cookie. If you use this feature, you will likely want to create conditional behaviour to support setting different cookies policies in development and production builds, as you will be opting out of the built-in dynamic policy. tip An example of a use case for this option is to support sharing session tokens across subdomains. Example â€‹ ```cookies: { sessionToken: { name: `__Secure-next-auth.session-token`, options: { httpOnly: true, sameSite: 'lax', path: '/', secure: true } }, callbackUrl: { name: `__Secure-next-auth.callback-url`, options: { sameSite: 'lax', path: '/', secure: true } }, csrfToken: { name: `__Host-next-auth.csrf-token`, options: { httpOnly: true, sameSite: 'lax', path: '/', secure: true } }, pkceCodeVerifier: { name: `${cookiePrefix}next-auth.pkce.code_verifier`, options: { httpOnly: true, sameSite: 'lax', path: '/', secure: useSecureCookies, maxAge: 900 } }, state: { name: `${cookiePrefix}next-auth.state`, options: { httpOnly: true, sameSite: "lax", path: "/", secure: useSecureCookies, maxAge: 900 }, }, nonce: { name: `${cookiePrefix}next-auth.nonce`, options: { httpOnly: true, sameSite: "lax", path: "/", secure: useSecureCookies, }, },}``` danger Using a custom cookie policy may introduce security flaws into your application and is intended as an option for advanced users who understand the implications. Using this option is not recommended. Override JWT ```encode``` and ```decode``` methods â€‹ NextAuth.js uses encrypted JSON Web Tokens ( JWE ) by default. Unless you have a good reason, we recommend keeping this behaviour. Although you can override this using the ```encode``` and ```decode``` methods. Both methods must be defined at the same time. IMPORTANT: If you use middleware to protect routes, make sure the same method is also set in the ```_middleware.ts``` options ```jwt: { async encode(params: { token: JWT secret: string maxAge: number }): Promise<string> { // return a custom encoded JWT string return "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c" }, async decode(params: { token: string secret: string }): Promise<JWT | null> { // return a `JWT` object, or `null` if decoding failed return {} },}```
OAuth Authentication Providers in NextAuth.js are OAuth definitions that allow your users to sign in with their favorite preexisting logins. You can use any of our many predefined providers, or write your own custom OAuth configuration. Using a built-in OAuth Provider (e.g Github, Twitter, Google, etc...) Using a custom OAuth Provider note NextAuth.js is designed to work with any OAuth service, it supports OAuth 1.0 , 1.0A , 2.0 and OpenID Connect and has built-in support for most popular sign-in services. Without going into too much detail, the OAuth flow generally has 6 parts: The application requests authorization to access service resources from the user If the user authorized the request, the application receives an authorization grant The application requests an access token from the authorization server (API) by presenting authentication of its own identity, and the authorization grant If the application identity is authenticated and the authorization grant is valid, the authorization server (API) issues an access token to the application. Authorization is complete. The application requests the resource from the resource server (API) and presents the access token for authentication If the access token is valid, the resource server (API) serves the resource to the application For more details, check out Aaron Parecki's blog post OAuth2 Simplified or Postman's blog post OAuth 2.0: Implicit Flow is Dead, Try PKCE Instead . How to â€‹ Register your application at the developer portal of your provider. There are usually links to the portals included in the aforementioned documentation pages for each supported provider with details on how to register your application. The redirect URI (sometimes called Callback URL) should follow this format: ```[origin]/api/auth/callback/[provider]``` ```[provider]``` refers to the ```id``` of your provider (see options ). For example, Twitter on ```localhost``` this would be: ```http://localhost:3000/api/auth/callback/twitter``` Using Google in our example application would look like this: ```https://next-auth-example.vercel.app/api/auth/callback/google``` Create a ```.env``` file at the root of your project and add the client ID and client secret. For Twitter this would be: ```TWITTER_ID=YOUR_TWITTER_CLIENT_IDTWITTER_SECRET=YOUR_TWITTER_CLIENT_SECRET``` Now you can add the provider settings to the NextAuth.js options object. You can add as many OAuth providers as you like, as you can see ```providers``` is an array. pages/api/auth/[...nextauth].js ```import TwitterProvider from "next-auth/providers/twitter"...providers: [ TwitterProvider({ clientId: process.env.TWITTER_ID, clientSecret: process.env.TWITTER_SECRET })],...``` Once a provider has been setup, you can sign in at the following URL: ```[origin]/api/auth/signin``` . This is an unbranded auto-generated page with all the configured providers. Options â€‹ Whenever you configure a custom or a built-in OAuth provider, you have the following options available: ```interface OAuthConfig { /** * OpenID Connect (OIDC) compliant providers can configure * this instead of `authorize`/`token`/`userinfo` options * without further configuration needed in most cases. * You can still use the `authorize`/`token`/`userinfo` * options for advanced control. * * [Authorization Server Metadata](https://datatracker.ietf.org/doc/html/rfc8414#section-3) */ wellKnown?: string /** * The login process will be initiated by sending the user to this URL. * * [Authorization endpoint](https://datatracker.ietf.org/doc/html/rfc6749#section-3.1) */ authorization: EndpointHandler<AuthorizationParameters> /** * Endpoint that returns OAuth 2/OIDC tokens and information about them. * This includes `access_token`, `id_token`, `refresh_token`, etc. * * [Token endpoint](https://datatracker.ietf.org/doc/html/rfc6749#section-3.2) */ token: EndpointHandler< UrlParams, { /** * Parameters extracted from the request to the `/api/auth/callback/:providerId` endpoint. * Contains params like `state`. */ params: CallbackParamsType /** * When using this custom flow, make sure to do all the necessary security checks. * This object contains parameters you have to match against the request to make sure it is valid. */ checks: OAuthChecks }, { tokens: TokenSet } > /** * When using an OAuth 2 provider, the user information must be requested * through an additional request from the userinfo endpoint. * * [Userinfo endpoint](https://www.oauth.com/oauth2-servers/signing-in-with-google/verifying-the-user-info) */ userinfo?: EndpointHandler<UrlParams, { tokens: TokenSet }, Profile> type: "oauth" /** * Used in URLs to refer to a certain provider. * @example /api/auth/callback/twitter // where the `id` is "twitter" */ id: string version: string profile(profile: P, tokens: TokenSet): Awaitable<User> checks?: ChecksType | ChecksType[] clientId: string clientSecret: string /** * If set to `true`, the user information will be extracted * from the `id_token` claims, instead of * making a request to the `userinfo` endpoint. * * `id_token` is usually present in OpenID Connect (OIDC) compliant providers. * * [`id_token` explanation](https://www.oauth.com/oauth2-servers/openid-connect/id-tokens) */ idToken?: boolean region?: string issuer?: string client?: Partial<ClientMetadata> allowDangerousEmailAccountLinking?: boolean /** * Object containing the settings for the styling of the providers sign-in buttons */ style: ProviderStyleType}``` ```authorization``` option â€‹ Configure how to construct the request to the Authorization endpoint . There are two ways to use this option: You can either set ```authorization``` to be a full URL, like ```"https://example.com/oauth/authorization?scope=email"``` . Use an object with ```url``` and ```params``` like so ```authorization: { url: "https://example.com/oauth/authorization", params: { scope: "email" }}``` tip If your Provider is OpenID Connect (OIDC) compliant, we recommend using the ```wellKnown``` option instead. ```token``` option â€‹ Configure how to construct the request to the Token endpoint . There are three ways to use this option: You can either set ```token``` to be a full URL, like ```"https://example.com/oauth/token?some=param"``` . Use an object with ```url``` and ```params``` like so ```token: { url: "https://example.com/oauth/token", params: { some: "param" }}``` Completely take control of the request: ```token: { url: "https://example.com/oauth/token", async request(context) { // context contains useful properties to help you make the request. const tokens = await makeTokenRequest(context) return { tokens } }}``` danger Option 3. should not be necessary in most cases, but if your provider does not follow the spec, or you have some very unique constraints it can be useful. Try to avoid it, if possible. tip If your Provider is OpenID Connect (OIDC) compliant, we recommend using the ```wellKnown``` option instead. ```userinfo``` option â€‹ A ```userinfo``` endpoint returns information about the logged-in user. It is not part of the OAuth specification, but usually available for most providers. There are three ways to use this option: You can either set ```userinfo``` to be a full URL, like ```"https://example.com/oauth/userinfo?some=param"``` . Use an object with ```url``` and ```params``` like so ```userinfo: { url: "https://example.com/oauth/userinfo", params: { some: "param" }}``` Completely take control of the request: ```userinfo: { url: "https://example.com/oauth/userinfo", // The result of this method will be the input to the `profile` callback. async request(context) { // context contains useful properties to help you make the request. return await makeUserinfoRequest(context) }}``` danger Option 3. should not be necessary in most cases, but if your provider does not follow the spec, or you have some very unique constraints it can be useful. Try to avoid it, if possible. tip In the rare case you don't care about what this endpoint returns, or your provider does not have one, you could create a noop function: ```userinfo: { request: () => {}}``` tip If your Provider is OpenID Connect (OIDC) compliant, we recommend using the ```wellKnown``` option instead. OIDC usually returns an ```id_token``` from the ```token``` endpoint. ```next-auth``` can decode the ```id_token``` to get the user information, instead of making an additional request to the ```userinfo``` endpoint. Just set ```idToken: true``` at the top-level of your provider configuration. If not set, ```next-auth``` will still try to contact this endpoint. ```client``` option â€‹ An advanced option, hopefully you won't need it in most cases. ```next-auth``` uses ```openid-client``` under the hood, see the docs on this option here . ```allowDangerousEmailAccountLinking``` option â€‹ Normally, when you sign in with an OAuth provider and another account with the same email address already exists, the accounts are not linked automatically. Automatic account linking on sign in is not secure between arbitrary providers and is disabled by default (see our Security FAQ ). However, it may be desirable to allow automatic account linking if you trust that the provider involved has securely verified the email address associated with the account. Just set ```allowDangerousEmailAccountLinking: true``` in your provider configuration to enable automatic account linking. Using a custom provider â€‹ You can use an OAuth provider that isn't built-in by using a custom object. As an example of what this looks like, this is the provider object returned for the Google provider: ```{ id: "google", name: "Google", type: "oauth", wellKnown: "https://accounts.google.com/.well-known/openid-configuration", authorization: { params: { scope: "openid email profile" } }, idToken: true, checks: ["pkce", "state"], profile(profile) { return { id: profile.sub, name: profile.name, email: profile.email, image: profile.picture, } },}``` As you can see, if your provider supports OpenID Connect and the ```/.well-known/openid-configuration``` endpoint contains support for the ```grant_type``` : ```authorization_code``` , you only need to pass the URL to that configuration file and define some basic fields like ```name``` and ```type``` . Otherwise, you can pass a more full set of URLs for each OAuth2.0 flow step, for example: ```{ id: "kakao", name: "Kakao", type: "oauth", authorization: "https://kauth.kakao.com/oauth/authorize", token: "https://kauth.kakao.com/oauth/token", userinfo: "https://kapi.kakao.com/v2/user/me", profile(profile) { return { id: profile.id, name: profile.kakao_account?.profile.nickname, email: profile.kakao_account?.email, image: profile.kakao_account?.profile.profile_image_url, } },}``` Replace all the options in this JSON object with the ones from your custom provider - be sure to give it a unique ID and specify the required URLs, and finally add it to the providers array when initializing the library: pages/api/auth/[...nextauth].js ```import TwitterProvider from "next-auth/providers/twitter"...providers: [ TwitterProvider({ clientId: process.env.TWITTER_ID, clientSecret: process.env.TWITTER_SECRET, }), { id: 'customProvider', name: 'CustomProvider', type: 'oauth', scope: '' // Make sure to request the users email address ... }]...``` Built-in providers â€‹ NextAuth.js comes with a set of built-in providers. You can find them here . Each built-in provider has its own documentation page: 42 School , Amazon Cognito , Apple , Atlassian , Auth0 , Authentik , Azure Active Directory , Azure Active Directory B2C , Battle.net , Box , BoxyHQ SAML , Bungie , Coinbase , Discord , Dropbox , DuendeIdentityServer6 , EVE Online , Facebook , FACEIT , Foursquare , Freshbooks , FusionAuth , GitHub , GitLab , Google , HubSpot , IdentityServer4 , Instagram , Kakao , Keycloak , LINE , LinkedIn , Mail.ru , Mailchimp , Medium , Naver , Netlify , Okta , OneLogin , Osso , Osu! , Patreon , Pinterest , Pipedrive , Reddit , Salesforce , Slack , Spotify , Strava , Todoist , Trakt , Twitch , Twitter , United Effects , VK , Wikimedia , WordPress.com , WorkOS , Yandex , Zitadel , Zoho , Zoom , Override default options â€‹ For built-in providers, in most cases you will only need to specify the ```clientId``` and ```clientSecret``` . If you need to override any of the defaults, add your own options . Even if you are using a built-in provider, you can override any of these options to tweak the default configuration. note The user provided options are deeply merged with the default options. That means you only have to override part of the options that you need to be different. For example if you want different scopes, overriding ```authorization.params.scope``` is enough, instead of the whole ```authorization``` option. /api/auth/[...nextauth].js ```import Auth0Provider from "next-auth/providers/auth0"Auth0Provider({ clientId: process.env.CLIENT_ID, clientSecret: process.env.CLIENT_SECRET, issuer: process.env.ISSUER, authorization: { params: { scope: "openid your_custom_scope" } },})``` Another example, the ```profile``` callback will return ```id``` , ```name``` , ```email``` and ```picture``` by default, but you might need more information from the provider. After setting the correct scopes, you can then do something like this: /api/auth/[...nextauth].js ```import GoogleProvider from "next-auth/providers/google"GoogleProvider({ clientId: process.env.GOOGLE_CLIENT_ID, clientSecret: process.env.GOOGLE_CLIENT_SECRET, profile(profile) { return { // Return all the profile information you need. // The only truly required field is `id` // to be able identify the account when added to a database } },})``` An example of how to enable automatic account linking: /api/auth/[...nextauth].js ```import GoogleProvider from "next-auth/providers/google"GoogleProvider({ clientId: process.env.GOOGLE_CLIENT_ID, clientSecret: process.env.GOOGLE_CLIENT_SECRET, allowDangerousEmailAccountLinking: true,})```
Email Install nodemailer â€‹ npm yarn pnpm ```npm install nodemailer``` ```yarn add nodemailer``` ```pnpm add nodemailer``` How to â€‹ The Email provider sends "magic links" via email that the user can click on to sign in. You have likely seen them before if you have used software like Slack. Adding support for signing in via email in addition to one or more OAuth services provides a way for users to sign in if they lose access to their OAuth account (e.g. if it is locked or deleted). Configuration is similar to other providers, but the options are different: pages/api/auth/[...nextauth].js ```import EmailProvider from "next-auth/providers/email"...providers: [ EmailProvider({ server: process.env.EMAIL_SERVER, from: process.env.EMAIL_FROM, // maxAge: 24 * 60 * 60, // How long email links are valid for (default 24h) }),],...``` See the Email provider documentation for more information on how to configure email sign in. note The email provider requires a database, it cannot be used without one. Options â€‹ Name Description Type Required id Unique ID for the provider ```string``` Yes name Descriptive name for the provider ```string``` Yes type Type of provider, in this case ```email``` ```"email"``` Yes server Path or object pointing to the email server ```string``` or ```Object``` Yes sendVerificationRequest Callback to execute when a verification request is sent ```(params) => Promise<undefined>``` Yes from The email address from which emails are sent, default: " no-reply@example.com " ```string``` No maxAge How long until the e-mail can be used to log the user in seconds. Defaults to 1 day ```number``` No
Credentials How to â€‹ The Credentials provider allows you to handle signing in with arbitrary credentials, such as a username and password, two-factor authentication or hardware device (e.g. YubiKey U2F / FIDO). It is intended to support use cases where you have an existing system you need to authenticate users against. pages/api/auth/[...nextauth].js ```import CredentialsProvider from "next-auth/providers/credentials"...providers: [ CredentialsProvider({ // The name to display on the sign in form (e.g. 'Sign in with...') name: 'Credentials', // The credentials is used to generate a suitable form on the sign in page. // You can specify whatever fields you are expecting to be submitted. // e.g. domain, username, password, 2FA token, etc. // You can pass any HTML attribute to the <input> tag through the object. credentials: { username: { label: "Username", type: "text", placeholder: "jsmith" }, password: { label: "Password", type: "password" } }, async authorize(credentials, req) { // You need to provide your own logic here that takes the credentials // submitted and returns either a object representing a user or value // that is false/null if the credentials are invalid. // e.g. return { id: 1, name: 'J Smith', email: 'jsmith@example.com' } // You can also use the `req` object to obtain additional parameters // (i.e., the request IP address) const res = await fetch("/your/endpoint", { method: 'POST', body: JSON.stringify(credentials), headers: { "Content-Type": "application/json" } }) const user = await res.json() // If no error and we have user data, return it if (res.ok && user) { return user } // Return null if user data could not be retrieved return null } })]...``` See the Credentials provider documentation for more information. note The Credentials provider can only be used if JSON Web Tokens are enabled for sessions. Users authenticated with the Credentials provider are not persisted in the database. Options â€‹ Name Description Type Required id Unique ID for the provider ```string``` Yes name Descriptive name for the provider ```string``` Yes type Type of provider, in this case ```credentials``` ```"credentials"``` Yes credentials The credentials to sign-in with ```Object``` Yes authorize Callback to execute once user is to be authorized ```(credentials, req) => Promise<User>``` Yes
Databases NextAuth.js offers multiple database adapters. Check out the overview . As of v4 NextAuth.js no longer ships with an adapter included by default. If you would like to persist any information, you need to install one of the many available adapters yourself. See the individual adapter documentation pages for more details. To learn more about databases in NextAuth.js and how they are used, check out databases in the FAQ . How to use a database â€‹ See the documentation for adapters for more information on advanced configuration, including how to use NextAuth.js with other databases using a custom adapter .
Pages NextAuth.js automatically creates simple, unbranded authentication pages for handling Sign in, Sign out, Email Verification and displaying error messages. The options displayed on the sign-up page are automatically generated based on the providers specified in the options passed to NextAuth.js. To add a custom login page, you can use the ```pages``` option: pages/api/auth/[...nextauth].js ```... pages: { signIn: '/auth/signin', signOut: '/auth/signout', error: '/auth/error', // Error code passed in query string as ?error= verifyRequest: '/auth/verify-request', // (used for check email message) newUser: '/auth/new-user' // New users will be directed here on first sign in (leave the property out if not of interest) }...``` note When using this configuration, ensure that these pages actually exist. For example ```error: '/auth/error'``` refers to a page file at ```pages/auth/error.js``` . Error codes â€‹ We purposefully restrict the returned error codes for increased security. Error page â€‹ The following errors are passed as error query parameters to the default or overridden error page: Configuration : There is a problem with the server configuration. Check if your options are correct. AccessDenied : Usually occurs, when you restricted access through the ```signIn``` callback , or ```redirect``` callback Verification : Related to the Email provider. The token has expired or has already been used Default : Catch all, will apply, if none of the above matched Example: ```/auth/error?error=Configuration``` Sign-in page â€‹ The following errors are passed as error query parameters to the default or overridden sign-in page: OAuthSignin : Error in constructing an authorization URL ( 1 , 2 , 3 ), OAuthCallback : Error in handling the response ( 1 , 2 , 3 ) from an OAuth provider. OAuthCreateAccount : Could not create OAuth provider user in the database. EmailCreateAccount : Could not create email provider user in the database. Callback : Error in the OAuth callback handler route OAuthAccountNotLinked : If the email on the account is already linked, but not with this OAuth account EmailSignin : Sending the e-mail with the verification token failed CredentialsSignin : The ```authorize``` callback returned ```null``` in the Credentials provider . We don't recommend providing information about which part of the credentials were wrong, as it might be abused by malicious hackers. SessionRequired : The content of this page requires you to be signed in at all times. See useSession for configuration. Default : Catch all, will apply, if none of the above matched Example: ```/auth/signin?error=Default``` Theming â€‹ By default, the built-in pages will follow the system theme, utilizing the ```prefer-color-scheme``` Media Query. You can override this to always use a dark or light theme, through the ```theme.colorScheme``` option . In addition, you can define a ```theme.brandColor``` to define a custom accent color for these built-in pages. You can also define a URL to a logo in ```theme.logo``` which will be rendered above the primary card in these pages. Sign In â€‹ Sign Out â€‹ Examples â€‹ OAuth Sign in â€‹ In order to get the available authentication providers and the URLs to use for them, you can make a request to the API endpoint ```/api/auth/providers``` : pages/auth/signin.tsx ```import type { GetServerSidePropsContext, InferGetServerSidePropsType } from "next";import { getProviders, signIn } from "next-auth/react"import { getServerSession } from "next-auth/next"import { authOptions } from "../api/auth/[...nextauth]";export default function SignIn({ providers }: InferGetServerSidePropsType<typeof getServerSideProps>) { return ( <> {Object.values(providers).map((provider) => ( <div key={provider.name}> <button onClick={() => signIn(provider.id)}> Sign in with {provider.name} </button> </div> ))} </> )}export async function getServerSideProps(context: GetServerSidePropsContext) { const session = await getServerSession(context.req, context.res, authOptions); // If the user is already logged in, redirect. // Note: Make sure not to redirect to the same page // To avoid an infinite loop! if (session) { return { redirect: { destination: "/" } }; } const providers = await getProviders(); return { props: { providers: providers ?? [] }, }}``` There is another, more fully styled example signin page available here . Email Sign in â€‹ If you create a custom sign in form for email sign in, you will need to submit both fields for the email address and csrfToken from /api/auth/csrf in a POST request to /api/auth/signin/email . pages/auth/email-signin.tsx ```import type { GetServerSidePropsContext, InferGetServerSidePropsType } from "next";import { getCsrfToken } from "next-auth/react"export default function SignIn({ csrfToken }: InferGetServerSidePropsType<typeof getServerSideProps>) { return ( <form method="post" action="/api/auth/signin/email"> <input name="csrfToken" type="hidden" defaultValue={csrfToken} /> <label> Email address <input type="email" id="email" name="email" /> </label> <button type="submit">Sign in with Email</button> </form> )}export async function getServerSideProps(context: GetServerSidePropsContext) { const csrfToken = await getCsrfToken(context) return { props: { csrfToken }, }}``` You can also use the ```signIn()``` function which will handle obtaining the CSRF token for you: ```signIn("email", { email: "jsmith@example.com" })``` Credentials Sign in â€‹ If you create a sign in form for credentials based authentication, you will need to pass a csrfToken from /api/auth/csrf in a POST request to /api/auth/callback/credentials . pages/auth/credentials-signin.tsx ```import type { GetServerSidePropsContext, InferGetServerSidePropsType } from "next";import { getCsrfToken } from "next-auth/react"export default function SignIn({ csrfToken }: InferGetServerSidePropsType<typeof getServerSideProps>) { return ( <form method="post" action="/api/auth/callback/credentials"> <input name="csrfToken" type="hidden" defaultValue={csrfToken} /> <label> Username <input name="username" type="text" /> </label> <label> Password <input name="password" type="password" /> </label> <button type="submit">Sign in</button> </form> )}export async function getServerSideProps(context: GetServerSidePropsContext) { return { props: { csrfToken: await getCsrfToken(context), }, }}``` You can also use the ```signIn()``` function which will handle obtaining the CSRF token for you: ```signIn("credentials", { username: "jsmith", password: "1234" })``` tip Remember to put any custom pages in a folder outside /pages/api which is reserved for API code. As per the examples above, a location convention suggestion is ```pages/auth/...``` .
Callbacks Callbacks are asynchronous functions you can use to control what happens when an action is performed. Callbacks are extremely powerful, especially in scenarios involving JSON Web Tokens as they allow you to implement access controls without a database and to integrate with external databases or APIs. tip If you want to pass data such as an Access Token or User ID to the browser when using JSON Web Tokens, you can persist the data in the token when the ```jwt``` callback is called, then pass the data through to the browser in the ```session``` callback. You can specify a handler for any of the callbacks below. pages/api/auth/[...nextauth].js ```... callbacks: { async signIn({ user, account, profile, email, credentials }) { return true }, async redirect({ url, baseUrl }) { return baseUrl }, async session({ session, user, token }) { return session }, async jwt({ token, user, account, profile, isNewUser }) { return token }...}``` The documentation below shows how to implement each callback, their default behaviour and an example of what the response for each callback should be. Note that configuration options and authentication providers you are using can impact the values passed to the callbacks. Sign in callback â€‹ Use the ```signIn()``` callback to control if a user is allowed to sign in. pages/api/auth/[...nextauth].js ```...callbacks: { async signIn({ user, account, profile, email, credentials }) { const isAllowedToSignIn = true if (isAllowedToSignIn) { return true } else { // Return false to display a default error message return false // Or you can return a URL to redirect to: // return '/unauthorized' } }}...``` When using the Email Provider the ```signIn()``` callback is triggered both when the user makes a Verification Request (before they are sent an email with a link that will allow them to sign in) and again after they activate the link in the sign-in email. Email accounts do not have profiles in the same way OAuth accounts do. On the first call during email sign in the ```email``` object will include a property ```verificationRequest: true``` to indicate it is being triggered in the verification request flow. When the callback is invoked after a user has clicked on a sign-in link, this property will not be present. You can check for the ```verificationRequest``` property to avoid sending emails to addresses or domains on a blocklist (or to only explicitly generate them for email address in an allow list). When using the Credentials Provider the ```user``` object is the response returned from the ```authorize``` callback and the ```profile``` object is the raw body of the ```HTTP POST``` submission. note When using NextAuth.js with a database, the User object will be either a user object from the database (including the User ID) if the user has signed in before or a simpler prototype user object (i.e. name, email, image) for users who have not signed in before. When using NextAuth.js without a database, the user object will always be a prototype user object, with information extracted from the profile. note Redirects returned by this callback cancel the authentication flow. Only redirect to error pages that, for example, tell the user why they're not allowed to sign in. To redirect to a page after a successful sign in, please use the ```callbackUrl``` option or the redirect callback . Redirect callback â€‹ The redirect callback is called anytime the user is redirected to a callback URL (e.g. on signin or signout). By default only URLs on the same URL as the site are allowed, you can use the redirect callback to customise that behaviour. The default redirect callback looks like this: pages/api/auth/[...nextauth].js ```...callbacks: { async redirect({ url, baseUrl }) { // Allows relative callback URLs if (url.startsWith("/")) return `${baseUrl}${url}` // Allows callback URLs on the same origin else if (new URL(url).origin === baseUrl) return url return baseUrl }}...``` note The redirect callback may be invoked more than once in the same flow. JWT callback â€‹ This callback is called whenever a JSON Web Token is created (i.e. at sign in) or updated (i.e whenever a session is accessed in the client). The returned value will be encrypted , and it is stored in a cookie. Requests to ```/api/auth/signin``` , ```/api/auth/session``` and calls to ```getSession()``` , ```getServerSession()``` , ```useSession()``` will invoke this function, but only if you are using a JWT session . This method is not invoked when you persist sessions in a database. As with database persisted session expiry times, token expiry time is extended whenever a session is active. The arguments user , account , profile and isNewUser are only passed the first time this callback is called on a new session, after the user signs in. In subsequent calls, only ```token``` will be available. The contents user , account , profile and isNewUser will vary depending on the provider and if you are using a database. You can persist data such as User ID, OAuth Access Token in this token, see the example below for ```access_token``` and ```user.id``` . To expose it on the client side, check out the ```session()``` callback as well. pages/api/auth/[...nextauth].js ```...callbacks: { async jwt({ token, account, profile }) { // Persist the OAuth access_token and or the user id to the token right after signin if (account) { token.accessToken = account.access_token token.id = profile.id } return token }}...``` tip Use an if branch to check for the existence of parameters (apart from ```token``` ). If they exist, this means that the callback is being invoked for the first time (i.e. the user is being signed in). This is a good place to persist additional data like an ```access_token``` in the JWT. Subsequent invocations will only contain the ```token``` parameter. Session callback â€‹ The session callback is called whenever a session is checked. By default, only a subset of the token is returned for increased security . If you want to make something available you added to the token (like ```access_token``` and ```user.id``` from above) via the ```jwt()``` callback, you have to explicitly forward it here to make it available to the client. e.g. ```getSession()``` , ```useSession()``` , ```/api/auth/session``` When using database sessions, the User ( ```user``` ) object is passed as an argument. When using JSON Web Tokens for sessions, the JWT payload ( ```token``` ) is provided instead. pages/api/auth/[...nextauth].js ```...callbacks: { async session({ session, token, user }) { // Send properties to the client, like an access_token and user id from a provider. session.accessToken = token.accessToken session.user.id = token.id return session }}...``` tip When using JSON Web Tokens the ```jwt()``` callback is invoked before the ```session()``` callback, so anything you add to the JSON Web Token will be immediately available in the session callback, like for example an ```access_token``` or ```id``` from a provider. danger The session object is not persisted server side, even when using database sessions - only data such as the session token, the user, and the expiry time is stored in the session table. If you need to persist session data server side, you can use the ```accessToken``` returned for the session as a key - and connect to the database in the ```session()``` callback to access it. Session ```accessToken``` values do not rotate and are valid as long as the session is valid. If using JSON Web Tokens instead of database sessions, you should use the User ID or a unique key stored in the token (you will need to generate a key for this yourself on sign in, as access tokens for sessions are not generated when using JSON Web Tokens).
Events Events are asynchronous functions that do not return a response, they are useful for audit logs / reporting or handling any other side-effects. You can specify a handler for any of these events below, for debugging or for an audit log. note The execution of your authentication API will be blocked by an ```await``` on your event handler. If your event handler starts any burdensome work it should not block its own promise on that work. Events â€‹ signIn â€‹ Sent on a successful sign in. The message will be an object and contain: ```user``` (from your adapter or from the provider if a ```credentials``` type provider) ```account``` (from your adapter or the provider) ```profile``` (from the provider, is ```undefined``` on ```credentials``` provider, use ```user``` instead) ```isNewUser``` (whether your adapter had a user for this account already) signOut â€‹ Sent when the user signs out. The message object will contain one of these depending on if you use JWT or database persisted sessions: ```token``` : The JWT token for this session. ```session``` : The session object from your adapter that is being ended createUser â€‹ Sent when the adapter is told to create a new user. The message object will contain the user. updateUser â€‹ Sent when the adapter is told to update an existing user. Currently, this is only sent when the user verifies their email address. The message object will contain the user. linkAccount â€‹ Sent when an account in a given provider is linked to a user in our user database. For example, when a user signs up with Twitter or when an existing user links their Google account. The message object will contain: ```user``` : The user object from your adapter. ```account``` : The object returned from the provider. ```profile``` : The object returned from the ```profile``` callback of the OAuth provider. session â€‹ Sent at the end of a request for the current session. The message object will contain one of these depending on if you use JWT or database persisted sessions: ```token``` : The JWT token for this session. ```session``` : The session object from your adapter.
Next.js ```unstable_getServerSession``` â€‹ This method was renamed to ```getServerSession``` . See the documentation below. ```getServerSession``` â€‹ When calling from server-side i.e. in API routes or in ```getServerSideProps``` , we recommend using this function instead of ```getSession``` to retrieve the ```session``` object. This method is especially useful when you are using NextAuth.js with a database. This method can drastically reduce response time when used over ```getSession``` on server-side, due to avoiding an extra ```fetch``` to an API Route (this is generally not recommended in Next.js ). In addition, ```getServerSession``` will correctly update the cookie expiry time and update the session content if ```callbacks.jwt``` or ```callbacks.session``` changed something. Otherwise, if you only want to get the session token, see ```getToken``` . ```getServerSession``` requires passing the same object you would pass to ```NextAuth``` when initializing NextAuth.js. To do so, you can export your NextAuth.js options in the following way: In ```[...nextauth].ts``` : ```import NextAuth from 'next-auth'import type { NextAuthOptions } from 'next-auth'export const authOptions: NextAuthOptions = { // your configs}export default NextAuth(authOptions);``` In ```getServerSideProps``` : â€‹ ```import { authOptions } from 'pages/api/auth/[...nextauth]'import { getServerSession } from "next-auth/next"export async function getServerSideProps(context) { const session = await getServerSession(context.req, context.res, authOptions) if (!session) { return { redirect: { destination: '/', permanent: false, }, } } return { props: { session, }, }}``` In API Routes: â€‹ ```import { authOptions } from 'pages/api/auth/[...nextauth]'import { getServerSession } from "next-auth/next"export async function handler(req, res) { const session = await getServerSession(req, res, authOptions) if (!session) { res.status(401).json({ message: "You must be logged in." }); return; } return res.json({ message: 'Success', })}``` In ```app/``` directory: â€‹ You can also use ```getServerSession``` in Next.js' server components: ```import { getServerSession } from "next-auth/next"import { authOptions } from "pages/api/auth/[...nextauth]"export default async function Page() { const session = await getServerSession(authOptions) return <pre>{JSON.stringify(session, null, 2)}</pre>}``` danger Currently, the underlying Next.js ```cookies()``` method only provides read access to the request cookies. This means that the ```expires``` value is stripped away from ```session``` in Server Components. Furthermore, there is a hard expiry on sessions, after which the user will be required to sign in again. (The default expiry is 30 days). Caching â€‹ Note that using this function implies personalized data and that you should not store pages or APIs using this in a public cache . For example a host like Vercel will implicitly prevent you from caching publicly due to the ```set-cookie``` header set by this function. Middleware â€‹ You can use a Next.js Middleware with NextAuth.js to protect your site. Next.js 12 has introduced Middleware . It is a way to run logic before accessing any page, even when they are static. On platforms like Vercel, Middleware is run at the Edge . If the following options look familiar, this is because they are a subset of these options . You can extract these to a common configuration object to reuse them. In the future, we would like to be able to run everything in Middleware. (See Caveats ). You can get the ```withAuth``` middleware function from ```next-auth/middleware``` either as a default or a named import: Prerequisites â€‹ You must set the same secret in the middleware that you use in NextAuth. The easiest way is to set the ```NEXTAUTH_SECRET``` environment variable. It will be picked up by both the NextAuth config , as well as the middleware config. Alternatively, you can provide the secret using the ```secret``` option in the middleware config. We strongly recommend replacing the ```secret``` value completely with this ```NEXTAUTH_SECRET``` environment variable. Basic usage â€‹ The most simple usage is when you want to require authentication for your entire site. You can add a ```middleware.js``` file with the following: ```export { default } from "next-auth/middleware"``` That's it! Your application is now secured. ðŸŽ‰ If you only want to secure certain pages, export a ```config``` object with a ```matcher``` : ```export { default } from "next-auth/middleware"export const config = { matcher: ["/dashboard"] }``` Now you will still be able to visit every page, but only ```/dashboard``` will require authentication. If a user is not logged in, the default behavior is to redirect them to the sign-in page. ```callbacks``` â€‹ Required: No Description â€‹ Callbacks are asynchronous functions you can use to control what happens when an action is performed. Example (default value) â€‹ ``` callbacks: { authorized({ req , token }) { if(token) return true // If there is a token, the user is authenticated } }``` ```pages``` â€‹ Required : No Description â€‹ Specify URLs to be used if you want to create custom sign in, and error pages. Pages specified will override the corresponding built-in page. note This should match the ```pages``` configuration that's found in ```[...nextauth].ts``` . Example (default value) â€‹ ```pages: { signIn: '/api/auth/signin', error: '/api/auth/error',}``` See the documentation for the pages option for more information. ```secret``` â€‹ Required : No Description â€‹ The same ```secret``` used in the NextAuth.js config . Example (default value) â€‹ ```secret: process.env.NEXTAUTH_SECRET``` Advanced usage â€‹ NextAuth.js Middleware is very flexible, there are multiple ways to use it. note If you do not define the options, NextAuth.js will use the default values for the omitted options. wrap middleware â€‹ middleware.ts ```import { withAuth } from "next-auth/middleware"export default withAuth( // `withAuth` augments your `Request` with the user's token. function middleware(req) { console.log(req.nextauth.token) }, { callbacks: { authorized: ({ token }) => token?.role === "admin", }, })export const config = { matcher: ["/admin"] }``` The ```middleware``` function will only be invoked if the ```authorized``` callback returns ```true``` . Custom JWT decode method â€‹ If you have a custom jwt decode method set in ```[...nextauth].ts``` , you must also pass the same ```decode``` method to ```withAuth``` in order to read the custom-signed JWT correctly. You may want to extract the encode/decode logic to a separate function for consistency. `` /api/auth/[...nextauth].ts ```import type { NextAuthOptions } from "next-auth"import NextAuth from "next-auth"import jwt from "jsonwebtoken"export const authOptions: NextAuthOptions = { providers: [...], jwt: { async encode({ secret, token }) { return jwt.sign(token, secret) }, async decode({ secret, token }) { return jwt.verify(token, secret) }, },}export default NextAuth(authOptions)``` And: middleware.ts ```import withAuth from "next-auth/middleware"import { authOptions } from "pages/api/auth/[...nextauth]";export default withAuth({ jwt: { decode: authOptions.jwt }, callbacks: { authorized: ({ token }) => !!token, },})``` Caveats â€‹ Currently only supports session verification, as parts of the sign-in code need to run in a Node.js environment. In the future, we would like to make sure that NextAuth.js can fully run at the Edge Only supports the ```"jwt"``` session strategy . We need to wait until databases at the Edge become mature enough to ensure a fast experience. (If you know of an Edge-compatible database, we would like if you proposed a new Adapter )
Overview Authentication Providers in NextAuth.js are services that can be used to sign in a user. There are four ways a user can be signed in: Using a built-in OAuth Provider (e.g Github, Twitter, Google, etc...) Using a custom OAuth Provider Using Email Using Credentials note NextAuth.js is designed to work with any OAuth service, it supports OAuth 1.0 , 1.0A , 2.0 and OpenID Connect (OIDC) and has built-in support for most popular sign-in services.
42 School note 42 returns a field on ```Account``` called ```created_at``` which is a number. See the docs . Make sure to add this field to your database schema, in case if you are using an Adapter . Documentation â€‹ https://api.intra.42.fr/apidoc/guides/web_application_flow Configuration â€‹ https://profile.intra.42.fr/oauth/applications/new Options â€‹ The 42 School Provider comes with a set of default options: 42 School Provider options You can override any of the options to suit your own use case. Example â€‹ ```import FortyTwoProvider from "next-auth/providers/42-school";...providers: [ FortyTwoProvider({ clientId: process.env.FORTY_TWO_CLIENT_ID, clientSecret: process.env.FORTY_TWO_CLIENT_SECRET })]...```
Apple Documentation â€‹ https://developer.apple.com/sign-in-with-apple/get-started/ Configuration â€‹ https://developer.apple.com/account/resources/identifiers/list/serviceId Options â€‹ The Apple Provider comes with a set of default options: Apple Provider options You can override any of the options to suit your own use case. Generating a secret â€‹ Apple requires the client secret to be a JWT. To generate one, you can use the following script: https://bal.so/apple-gen-secret . For more information, see the Apple docs Then, you can paste the result into your ```.env.local``` file under ```APPLE_SECRET``` , so you can refer to it from your code: ```import AppleProvider from "next-auth/providers/apple";...providers: [ AppleProvider({ clientId: process.env.APPLE_ID, clientSecret: process.env.APPLE_SECRET })]...``` tip The TeamID is located on the top right after logging in. tip The KeyID is located after you create the key. Look for it before you download the k8 file. Testing on a development server â€‹ tip Apple requires all sites to run HTTPS (including local development instances). tip Apple doesn't allow you to use localhost in domains or subdomains. Host name resolution â€‹ Edit your host file and point your site to ```127.0.0.1``` . Linux/macOS ```echo '127.0.0.1 dev.example.com' | sudo tee -a /etc/hosts``` Windows (run PowerShell as administrator) ```Add-Content -Path C:\Windows\System32\drivers\etc\hosts -Value "127.0.0.1 dev.example.com" -Force``` More info: How to edit my host file? Create certificate â€‹ Create a directory ```certificates``` and add the certificate files ```localhost.key``` and ```localhost.crt``` , which you generate using OpenSSL: Linux/macOS ```openssl req -x509 -out localhost.crt -keyout localhost.key \ -newkey rsa:2048 -nodes -sha256 \ -subj "/CN=localhost" -extensions EXT -config <( \ printf "[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth")``` Windows The OpenSSL executable is distributed with Git for Windows. Once installed you will find the openssl.exe file in ```C:\Program Files\Git\mingw64\bin``` , which you can add to the system PATH environment variable if itâ€™s not already done. Add environment variable ```OPENSSL_CONF=C:\Program Files\Git\mingw64\ssl\openssl.cnf``` ``` req -x509 -out localhost.crt -keyout localhost.key \ -newkey rsa:2048 -nodes -sha256 \ -subj "/CN=localhost"``` Deploy to server â€‹ You can create a ```server.js``` in the root of your project and run it with ```node server.js``` to test Sign in with Apple integration locally: ```const { createServer } = require("https")const { parse } = require("url")const next = require("next")const fs = require("fs")const dev = process.env.NODE_ENV !== "production"const app = next({ dev })const handle = app.getRequestHandler()const httpsOptions = { key: fs.readFileSync("./certificates/localhost.key"), cert: fs.readFileSync("./certificates/localhost.crt"),}app.prepare().then(() => { createServer(httpsOptions, (req, res) => { const parsedUrl = parse(req.url, true) handle(req, res, parsedUrl) }).listen(3000, (err) => { if (err) throw err console.log("> Ready on https://localhost:3000") })})``` Helpful guides â€‹ How to setup localhost with HTTPS with a Next.js app Guide to configuring Sign in with Apple
Atlassian Documentation â€‹ https://developer.atlassian.com/cloud/jira/platform/oauth-2-authorization-code-grants-3lo-for-apps/#implementing-oauth-2-0--3lo- Options â€‹ The Atlassian Provider comes with a set of default options: Atlassian Provider options You can override any of the options to suit your own use case. Example â€‹ ```import AtlassianProvider from "next-auth/providers/atlassian";...providers: [ AtlassianProvider({ clientId: process.env.ATLASSIAN_CLIENT_ID, clientSecret: process.env.ATLASSIAN_CLIENT_SECRET, authorization: { params: { scope: "write:jira-work read:jira-work read:jira-user offline_access read:me" } } })]...``` Instructions â€‹ Configuration â€‹ tip An app can be created at https://developer.atlassian.com/apps/ Under "Apis and features" in the side menu, configure the following for "OAuth 2.0 (3LO)": Redirect URL http://localhost:3000/api/auth/callback/atlassian danger To enable access to Jira Platform REST API you must enable User Identity API and add ```read:me``` to your provider scope option.
Auth0 Documentation â€‹ https://auth0.com/docs/api/authentication#authorize-application Configuration â€‹ https://manage.auth0.com/dashboard Options â€‹ The Auth0 Provider comes with a set of default options: Auth0 Provider options You can override any of the options to suit your own use case. Example â€‹ ```import Auth0Provider from "next-auth/providers/auth0";...providers: [ Auth0Provider({ clientId: process.env.AUTH0_CLIENT_ID, clientSecret: process.env.AUTH0_CLIENT_SECRET, issuer: process.env.AUTH0_ISSUER })]...``` note ```issuer``` should be the fully qualified URL â€“ e.g. ```https://dev-s6clz2lv.eu.auth0.com```
Authentik Documentation â€‹ https://goauthentik.io/docs/providers/oauth2 Options â€‹ The Authentik Provider comes with a set of default options: Authentik Provider options You can override any of the options to suit your own use case. Example â€‹ ```import AuthentikProvider from "next-auth/providers/authentik";...providers: [ AuthentikProvider({ clientId: process.env.AUTHENTIK_ID, clientSecret: process.env.AUTHENTIK_SECRET, issuer: process.env.AUTHENTIK_ISSUER, })]...``` note ```issuer``` should include the slug without a trailing slash â€“ e.g., ```https://my-authentik-domain.com/application/o/My_Slug```
Azure Active Directory B2C note Azure AD B2C returns the following fields on ```Account``` : ```refresh_token_expires_in``` (number) ```not_before``` (number) ```id_token_expires_in``` (number) ```profile_info``` (string). See their docs . Remember to add these fields to your database schema, in case if you are using an Adapter . Documentation â€‹ https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-auth-code-flow Configuration â€‹ https://docs.microsoft.com/azure/active-directory-b2c/tutorial-create-tenant Options â€‹ The Azure Active Directory Provider comes with a set of default options: Azure Active Directory Provider options You can override any of the options to suit your own use case. Configuration (Basic) â€‹ Basic configuration sets up Azure AD B2C to return an ID Token. This should be done as a prerequisite prior to running through the Advanced configuration. Step 1: Azure AD B2C Tenant https://docs.microsoft.com/en-us/azure/active-directory-b2c/tutorial-create-tenant Step 2: App Registration https://docs.microsoft.com/en-us/azure/active-directory-b2c/tutorial-register-applications Step 3: User Flow https://docs.microsoft.com/en-us/azure/active-directory-b2c/tutorial-create-user-flows Note: For the step "User attributes and token claims" you might minimally: Collect attribute: Email Address Display Name Given Name Surname Return claim: Email Addresses Display Name Given Name Surname Identity Provider Identity Provider Access Token User's Object ID Example â€‹ In ```.env.local``` create the following entries: ```AZURE_AD_B2C_TENANT_NAME=<copy the B2C tenant name here from Step 1>AZURE_AD_B2C_CLIENT_ID=<copy Application (client) ID here from Step 2>AZURE_AD_B2C_CLIENT_SECRET=<copy generated secret value here from Step 2>AZURE_AD_B2C_PRIMARY_USER_FLOW=<copy the name of the signin user flow you created from Step 3>``` In ```pages/api/auth/[...nextauth].js``` find or add the AZURE_AD_B2C entries: ```import AzureADB2CProvider from "next-auth/providers/azure-ad-b2c";...providers: [ AzureADB2CProvider({ tenantId: process.env.AZURE_AD_B2C_TENANT_NAME, clientId: process.env.AZURE_AD_B2C_CLIENT_ID, clientSecret: process.env.AZURE_AD_B2C_CLIENT_SECRET, primaryUserFlow: process.env.AZURE_AD_B2C_PRIMARY_USER_FLOW, authorization: { params: { scope: "offline_access openid" } }, }),]...``` Configuration (Advanced) â€‹ Advanced configuration sets up Azure AD B2C to return an Authorization Token. This builds on the steps completed in the Basic configuration above. Step 4: Add a Web API application https://docs.microsoft.com/en-us/azure/active-directory-b2c/tutorial-single-page-app-webapi?tabs=app-reg-ga Note: this is a second app registration (similar to Step 2) but with different setup and configuration. Example â€‹ Nothing in ```.env.local``` needs to change here. The only update is in ```pages/api/auth/[...nextauth].js``` where you will need to add the additional scopes that were created in Step 4 above: ```import AzureADB2CProvider from "next-auth/providers/azure-ad-b2c";...providers: [ AzureADB2CProvider({ tenantId: process.env.AZURE_AD_B2C_TENANT_NAME, clientId: process.env.AZURE_AD_B2C_CLIENT_ID, clientSecret: process.env.AZURE_AD_B2C_CLIENT_SECRET, primaryUserFlow: process.env.AZURE_AD_B2C_PRIMARY_USER_FLOW, authorization: { params: { scope: `https://${process.env.AZURE_AD_B2C_TENANT_NAME}.onmicrosoft.com/api/demo.read https://${process.env.AZURE_AD_B2C_TENANT_NAME}.onmicrosoft.com/api/demo.write offline_access openid` } }, }),]...```
Azure Active Directory note Azure Active Directory returns the following fields on ```Account``` : ```token_type``` (string) ```expires_in``` (number) ```ext_expires_in``` (number) ```access_token``` (string). Remember to add these fields to your database schema, in case if you are using an Adapter . Documentation â€‹ https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow Configuration â€‹ https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app Example â€‹ To allow specific Active Directory users access: â€‹ In https://portal.azure.com/ search for "Azure Active Directory", and select your organization. Next, go to "App Registration" in the left menu, and create a new one. Pay close attention to "Who can use this application or access this API?" This allows you to scope access to specific types of user accounts Only your tenant, all azure tenants, or all azure tenants and public Microsoft accounts (Skype, Xbox, Outlook.com, etc.) When asked for a redirection URL, select the platform type "Web" and use ```https://yourapplication.com/api/auth/callback/azure-ad``` or for development ```http://localhost:3000/api/auth/callback/azure-ad``` . After your App Registration is created, under "Client Credential" create your Client secret. Now copy your: Application (client) ID Directory (tenant) ID Client secret (value) In ```.env.local``` create the following entries: ```AZURE_AD_CLIENT_ID=<copy Application (client) ID here>AZURE_AD_CLIENT_SECRET=<copy generated client secret value here>AZURE_AD_TENANT_ID=<copy the tenant id here>``` That will default the tenant to use the ```common``` authorization endpoint. For more details see here . note Azure AD returns the profile picture in an ArrayBuffer, instead of just a URL to the image, so our provider converts it to a base64 encoded image string and returns that instead. See: https://docs.microsoft.com/en-us/graph/api/profilephoto-get?view=graph-rest-1.0#examples . The default image size is 48x48 to avoid running out of space in case the session is saved as a JWT. In ```pages/api/auth/[...nextauth].js``` find or add the ```AzureAD``` entries: ```import AzureADProvider from "next-auth/providers/azure-ad";...providers: [ AzureADProvider({ clientId: process.env.AZURE_AD_CLIENT_ID, clientSecret: process.env.AZURE_AD_CLIENT_SECRET, tenantId: process.env.AZURE_AD_TENANT_ID, }),]...```
Battle.net Documentation â€‹ https://develop.battle.net/documentation/guides/using-oauth Configuration â€‹ https://develop.battle.net/access/clients Options â€‹ The Battle.net Provider comes with a set of default options: Battle.net Provider options You can override any of the options to suit your own use case. Example â€‹ ```import BattleNetProvider from "next-auth/providers/battlenet";...providers: [ BattleNetProvider({ clientId: process.env.BATTLENET_CLIENT_ID, clientSecret: process.env.BATTLENET_CLIENT_SECRET, issuer: process.env.BATTLENET_ISSUER })]...``` ```issuer``` must be one of these values, based on the available regions : ```type BattleNetIssuer = | "https://www.battlenet.com.cn/oauth" | "https://us.battle.net/oauth" | "https://eu.battle.net/oauth" | "https://kr.battle.net/oauth" | "https://tw.battle.net/oauth"```
Box Documentation â€‹ https://developer.box.com/reference/ Configuration â€‹ https://developer.box.com/guides/sso-identities-and-app-users/connect-okta-to-app-users/configure-box/ Options â€‹ The Box Provider comes with a set of default options: Box Provider options You can override any of the options to suit your own use case. Example â€‹ ```import BoxProvider from "next-auth/providers/box";...providers: [ BoxProvider({ clientId: process.env.BOX_CLIENT_ID, clientSecret: process.env.BOX_CLIENT_SECRET })]...```
BoxyHQ SAML Documentation â€‹ BoxyHQ SAML is an open source service that handles the SAML login flow as an OAuth 2.0 flow, abstracting away all the complexities of the SAML protocol. You can deploy BoxyHQ SAML as a separate service or embed it into your app using our NPM library. Check out the documentation for more details Configuration â€‹ SAML login requires a configuration for every tenant of yours. One common method is to use the domain for an email address to figure out which tenant they belong to. You can also use a unique tenant ID (string) from your backend for this, typically some kind of account or organization ID. Check out the documentation for more details. Options â€‹ The BoxyHQ SAML Provider comes with a set of default options: BoxyHQ Provider options You can override any of the options to suit your own use case. Example â€‹ ```import BoxyHQSAMLProvider from "next-auth/providers/boxyhq-saml"...providers: [ BoxyHQSAMLProvider({ issuer: "http://localhost:5225", clientId: "dummy", // The dummy here is necessary since we'll pass tenant and product custom attributes in the client code clientSecret: "dummy", // The dummy here is necessary since we'll pass tenant and product custom attributes in the client code })}...``` On the client side you'll need to pass additional parameters ```tenant``` and ```product``` to the ```signIn``` function. This will allow BoxyHQL SAML to figure out the right SAML configuration and take your user to the right SAML Identity Provider to sign them in. ```import { signIn } from "next-auth/react";... // Map your users's email to a tenant and product const tenant = email.split("@")[1]; const product = 'my_awesome_product';... <Button onClick={async (event) => { event.preventDefault(); signIn("boxyhq-saml", {}, { tenant, product }); }}>...```
Bungie Documentation â€‹ https://github.com/Bungie-net/api/wiki/OAuth-Documentation Configuration â€‹ https://www.bungie.net/en/Application Options â€‹ The Bungie Provider comes with a set of default options: Bungie Provider options You can override any of the options to suit your own use case. Example â€‹ ```import BungieProvider from "next-auth/providers/bungie";...providers: [ BungieProvider({ clientId: process.env.BUNGIE_CLIENT_ID, clientSecret: process.env.BUNGIE_SECRET, headers: { "X-API-Key": process.env.BUNGIE_API_KEY } }),]...``` Configuration â€‹ tip Bungie require all sites to run HTTPS (including local development instances). tip Bungie doesn't allow you to use localhost as the website URL, instead you need to use https://127.0.0.1:3000 Navigate to https://www.bungie.net/en/Application and fill in the required details: Application name Application Status Website OAuth Client Type Confidential Redirect URL https://localhost:3000/api/auth/callback/bungie Scope ```Access items like your Bungie.net notifications, memberships, and recent Bungie.Net forum activity.``` Origin Header The following guide may be helpful: How to setup localhost with HTTPS with a Next.js app Example server â€‹ You will need to edit your host file and point your site at ```127.0.0.1``` How to edit my host file? On Windows (Run Powershell as administrator) ```Add-Content -Path C:\Windows\System32\drivers\etc\hosts -Value "127.0.0.1`tdev.example.com" -Force``` ```127.0.0.1 dev.example.com``` Create certificate â€‹ Creating a certificate for localhost is easy with openssl. Just put the following command in the terminal. The output will be two files: localhost.key and localhost.crt. ```openssl req -x509 -out localhost.crt -keyout localhost.key \ -newkey rsa:2048 -nodes -sha256 \ -subj "/CN=localhost" -extensions EXT -config <( \ printf "[dn]\nCN=localhost\n[req]\ndistinguished_name = dn\n[EXT]\nsubjectAltName=DNS:localhost\nkeyUsage=digitalSignature\nextendedKeyUsage=serverAuth")``` tip Windows The OpenSSL executable is distributed with Git for Windows. Once installed you will find the openssl.exe file in ```C:/Program Files/Git/mingw64/bin``` which you can add to the system PATH environment variable if itâ€™s not already done. Add environment variable ```OPENSSL_CONF=C:/Program Files/Git/mingw64/ssl/openssl.cnf``` ``` req -x509 -out localhost.crt -keyout localhost.key \ -newkey rsa:2048 -nodes -sha256 \ -subj "/CN=localhost"``` Create directory ```certificates``` and place ```localhost.key``` and ```localhost.crt``` You can create a ```server.js``` in the root of your project and run it with ```node server.js``` to test Sign in with Bungie integration locally: ```const { createServer } = require("https")const { parse } = require("url")const next = require("next")const fs = require("fs")const dev = process.env.NODE_ENV !== "production"const app = next({ dev })const handle = app.getRequestHandler()const httpsOptions = { key: fs.readFileSync("./certificates/localhost.key"), cert: fs.readFileSync("./certificates/localhost.crt"),}app.prepare().then(() => { createServer(httpsOptions, (req, res) => { const parsedUrl = parse(req.url, true) handle(req, res, parsedUrl) }).listen(3000, (err) => { if (err) throw err console.log("> Ready on https://localhost:3000") })})```
Amazon Cognito Documentation â€‹ https://docs.aws.amazon.com/cognito/latest/developerguide/cognito-userpools-server-contract-reference.html Configuration â€‹ https://console.aws.amazon.com/cognito/users/ You need to select your AWS region to go the the Cognito dashboard. Options â€‹ The Amazon Cognito Provider comes with a set of default options: Amazon Cognito Provider options You can override any of the options to suit your own use case. Example â€‹ ```import CognitoProvider from "next-auth/providers/cognito";...providers: [ CognitoProvider({ clientId: process.env.COGNITO_CLIENT_ID, clientSecret: process.env.COGNITO_CLIENT_SECRET, issuer: process.env.COGNITO_ISSUER, })]...``` tip The issuer is a URL, that looks like this: ```https://cognito-idp.{region}.amazonaws.com/{PoolId}``` ```PoolId``` is from ```General Settings``` in Cognito, not to be confused with the App Client ID. danger Make sure you select all the appropriate client settings or the OAuth flow will not work.
Coinbase Documentation â€‹ https://developers.coinbase.com/api/v2 Configuration â€‹ https://www.coinbase.com/settings/api Options â€‹ The Coinbase Provider comes with a set of default options: Coinbase Provider options You can override any of the options to suit your own use case. Example â€‹ ```import CoinbaseProvider from "next-auth/providers/coinbase";...providers: [ CoinbaseProvider({ clientId: process.env.COINBASE_CLIENT_ID, clientSecret: process.env.COINBASE_CLIENT_SECRET })]...``` tip This Provider template has a 2 hour access token to it. A refresh token is also returned.
Credentials Overview â€‹ The Credentials provider allows you to handle signing in with arbitrary credentials, such as a username and password, domain, or two factor authentication or hardware device (e.g. YubiKey U2F / FIDO). It is intended to support use cases where you have an existing system you need to authenticate users against. It comes with the constraint that users authenticated in this manner are not persisted in the database, and consequently that the Credentials provider can only be used if JSON Web Tokens are enabled for sessions. danger The functionality provided for credentials based authentication is intentionally limited to discourage use of passwords due to the inherent security risks associated with them and the additional complexity associated with supporting usernames and passwords. Options â€‹ The Credentials Provider comes with a set of default options: Credentials Provider options You can override any of the options to suit your own use case. Example - Username / Password â€‹ The Credentials provider is specified like other providers, except that you need to define a handler for ```authorize()``` that accepts credentials submitted via HTTP POST as input and returns either: A ```user``` object, which indicates the credentials are valid. If you return an object it will be persisted to the JSON Web Token and the user will be signed in, unless a custom ```signIn()``` callback is configured that subsequently rejects it. If you return ```null``` then an error will be displayed advising the user to check their details. If you throw an Error, the user will be sent to the error page with the error message as a query parameter. The Credentials provider's ```authorize()``` method also provides the request object as the second parameter (see example below). pages/api/auth/[...nextauth].js ```import CredentialsProvider from "next-auth/providers/credentials";...providers: [ CredentialsProvider({ // The name to display on the sign in form (e.g. "Sign in with...") name: "Credentials", // `credentials` is used to generate a form on the sign in page. // You can specify which fields should be submitted, by adding keys to the `credentials` object. // e.g. domain, username, password, 2FA token, etc. // You can pass any HTML attribute to the <input> tag through the object. credentials: { username: { label: "Username", type: "text", placeholder: "jsmith" }, password: { label: "Password", type: "password" } }, async authorize(credentials, req) { // Add logic here to look up the user from the credentials supplied const user = { id: "1", name: "J Smith", email: "jsmith@example.com" } if (user) { // Any object returned will be saved in `user` property of the JWT return user } else { // If you return null then an error will be displayed advising the user to check their details. return null // You can also Reject this callback with an Error thus the user will be sent to the error page with the error message as a query parameter } } })]...``` See the callbacks documentation for more information on how to interact with the token. Example - Web3 / Signin With Ethereum â€‹ The credentials provider can also be used to integrate with a service like Sign-in With Ethereum . For more information, check out the links below: Tutorial Example App Repo . Example App Demo . Multiple providers â€‹ Example â€‹ You can specify more than one credentials provider by specifying a unique ```id``` for each one. You can also use them in conjunction with other provider options. As with all providers, the order you specify them is the order they are displayed on the sign in page. ```providers: [ CredentialsProvider({ id: "domain-login", name: "Domain Account", async authorize(credentials, req) { const user = { /* add function to get user */ } return user }, credentials: { domain: { label: "Domain", type: "text ", placeholder: "CORPNET", value: "CORPNET", }, username: { label: "Username", type: "text ", placeholder: "jsmith" }, password: { label: "Password", type: "password" }, }, }), CredentialsProvider({ id: "intranet-credentials", name: "Two Factor Auth", async authorize(credentials, req) { const user = { /* add function to get user */ } return user }, credentials: { email: { label: "Username", type: "text ", placeholder: "jsmith" }, "2fa-key": { label: "2FA Key" }, }, }), /* ... additional providers ... /*/]```
Discord Documentation â€‹ https://discord.com/developers/docs/topics/oauth2 Configuration â€‹ https://discord.com/developers/applications Options â€‹ The Discord Provider comes with a set of default options: Discord Provider options You can override any of the options to suit your own use case. Example â€‹ ```import DiscordProvider from "next-auth/providers/discord";...providers: [ DiscordProvider({ clientId: process.env.DISCORD_CLIENT_ID, clientSecret: process.env.DISCORD_CLIENT_SECRET })]...```
Dropbox Documentation â€‹ https://developers.dropbox.com/oauth-guide Configuration â€‹ https://www.dropbox.com/developers/apps Options â€‹ The Dropbox Provider comes with a set of default options: Dropbox Provider options You can override any of the options to suit your own use case. Example â€‹ ```import DropboxProvider from "next-auth/providers/dropbox";...providers: [ DropboxProvider({ clientId: process.env.DROPBOX_CLIENT_ID, clientSecret: process.env.DROPBOX_CLIENT_SECRET })]...```
DuendeIdentityServer6 Documentation â€‹ https://docs.duendesoftware.com/identityserver/v6 Options â€‹ The DuendeIdentityServer6 Provider comes with a set of default options: DuendeIdentityServer6 Provider options You can override any of the options to suit your own use case. Example â€‹ ```import DuendeIDS6Provider from "next-auth/providers/duende-identity-server6"...providers: [ DuendeIDS6Provider({ clientId: process.env.DUENDE_IDS6_ID, clientSecret: process.env.DUENDE_IDS6_SECRET, issuer: process.env.DUENDE_IDS6_ISSUER, })]...``` Demo IdentityServer â€‹ The configuration below is for the demo server at https://demo.duendesoftware.com/ If you want to try it out, you can copy and paste the configuration below. You can sign in to the demo service with either bob/bob or alice/alice . ```import DuendeIDS6Provider from "next-auth/providers/duende-identity-server6"...providers: [ DuendeIDS6Provider({ clientId: "interactive.confidential", clientSecret: "secret", issuer: "https://demo.duendesoftware.com", })]...```
Email Overview â€‹ The Email provider uses email to send "magic links" that can be used to sign in, you will likely have seen these if you have used services like Slack before. Adding support for signing in via email in addition to one or more OAuth services provides a way for users to sign in if they lose access to their OAuth account (e.g. if it is locked or deleted). The Email provider can be used in conjunction with (or instead of) one or more OAuth providers. How it works â€‹ On initial sign in, a Verification Token is sent to the email address provided. By default this token is valid for 24 hours. If the Verification Token is used within that time (i.e. by clicking on the link in the email) an account is created for the user and they are signed in. If someone provides the email address of an existing account when signing in, an email is sent and they are signed into the account associated with that email address when they follow the link in the email. tip The Email Provider can be used with both JSON Web Tokens and database sessions, but you must configure a database to use it. It is not possible to enable email sign in without using a database. Options â€‹ The Email Provider comes with a set of default options: Email Provider options You can override any of the options to suit your own use case. Configuration â€‹ NextAuth.js does not include ```nodemailer``` as a dependency, so you'll need to install it yourself if you want to use the Email Provider. Run ```npm install nodemailer``` or ```yarn add nodemailer``` . You will need an SMTP account; ideally for one of the services known to work with ```nodemailer``` . There are two ways to configure the SMTP server connection. You can either use a connection string or a ```nodemailer``` configuration object. 2.1 Using a connection string Create an ```.env``` file to the root of your project and add the connection string and email address. .env ``` EMAIL_SERVER=smtp://username:password@smtp.example.com:587 EMAIL_FROM=noreply@example.com``` Now you can add the email provider like this: pages/api/auth/[...nextauth].js ```import EmailProvider from "next-auth/providers/email";...providers: [ EmailProvider({ server: process.env.EMAIL_SERVER, from: process.env.EMAIL_FROM }),],``` 2.2 Using a configuration object In your ```.env``` file in the root of your project simply add the configuration object options individually: .env ```EMAIL_SERVER_USER=usernameEMAIL_SERVER_PASSWORD=passwordEMAIL_SERVER_HOST=smtp.example.comEMAIL_SERVER_PORT=587EMAIL_FROM=noreply@example.com``` Now you can add the provider settings to the NextAuth.js options object in the Email Provider. pages/api/auth/[...nextauth].js ```import EmailProvider from "next-auth/providers/email";...providers: [ EmailProvider({ server: { host: process.env.EMAIL_SERVER_HOST, port: process.env.EMAIL_SERVER_PORT, auth: { user: process.env.EMAIL_SERVER_USER, pass: process.env.EMAIL_SERVER_PASSWORD } }, from: process.env.EMAIL_FROM }),],``` Do not forget to setup one of the database adapters for storing the Email verification token. You can now sign in with an email address at ```/api/auth/signin``` . A user account (i.e. an entry in the Users table) will not be created for the user until the first time they verify their email address. If an email address is already associated with an account, the user will be signed in to that account when they use the link in the email. Customizing emails â€‹ You can fully customize the sign in email that is sent by passing a custom function as the ```sendVerificationRequest``` option to ```EmailProvider()``` . e.g. pages/api/auth/[...nextauth].js ```import EmailProvider from "next-auth/providers/email";...providers: [ EmailProvider({ server: process.env.EMAIL_SERVER, from: process.env.EMAIL_FROM, sendVerificationRequest({ identifier: email, url, provider: { server, from }, }) { /* your function */ }, }),]``` The following code shows the complete source for the built-in ```sendVerificationRequest()``` method: ```import { createTransport } from "nodemailer"async function sendVerificationRequest(params) { const { identifier, url, provider, theme } = params const { host } = new URL(url) // NOTE: You are not required to use `nodemailer`, use whatever you want. const transport = createTransport(provider.server) const result = await transport.sendMail({ to: identifier, from: provider.from, subject: `Sign in to ${host}`, text: text({ url, host }), html: html({ url, host, theme }), }) const failed = result.rejected.concat(result.pending).filter(Boolean) if (failed.length) { throw new Error(`Email(s) (${failed.join(", ")}) could not be sent`) }}/** * Email HTML body * Insert invisible space into domains from being turned into a hyperlink by email * clients like Outlook and Apple mail, as this is confusing because it seems * like they are supposed to click on it to sign in. * * @note We don't add the email address to avoid needing to escape it, if you do, remember to sanitize it! */function html(params: { url: string; host: string; theme: Theme }) { const { url, host, theme } = params const escapedHost = host.replace(/\./g, "&#8203;.") const brandColor = theme.brandColor || "#346df1" const color = { background: "#f9f9f9", text: "#444", mainBackground: "#fff", buttonBackground: brandColor, buttonBorder: brandColor, buttonText: theme.buttonText || "#fff", } return `<body style="background: ${color.background};"> <table width="100%" border="0" cellspacing="20" cellpadding="0" style="background: ${color.mainBackground}; max-width: 600px; margin: auto; border-radius: 10px;"> <tr> <td align="center" style="padding: 10px 0px; font-size: 22px; font-family: Helvetica, Arial, sans-serif; color: ${color.text};"> Sign in to <strong>${escapedHost}</strong> </td> </tr> <tr> <td align="center" style="padding: 20px 0;"> <table border="0" cellspacing="0" cellpadding="0"> <tr> <td align="center" style="border-radius: 5px;" bgcolor="${color.buttonBackground}"><a href="${url}" target="_blank" style="font-size: 18px; font-family: Helvetica, Arial, sans-serif; color: ${color.buttonText}; text-decoration: none; border-radius: 5px; padding: 10px 20px; border: 1px solid ${color.buttonBorder}; display: inline-block; font-weight: bold;">Sign in</a></td> </tr> </table> </td> </tr> <tr> <td align="center" style="padding: 0px 0px 10px 0px; font-size: 16px; line-height: 22px; font-family: Helvetica, Arial, sans-serif; color: ${color.text};"> If you did not request this email you can safely ignore it. </td> </tr> </table></body>`}/** Email Text body (fallback for email clients that don't render HTML, e.g. feature phones) */function text({ url, host }: { url: string; host: string }) { return `Sign in to ${host}\n${url}\n\n`}``` tip If you want to generate great looking email client compatible HTML with React, check out https://mjml.io Customizing the Verification Token â€‹ By default, we are generating a random verification token. You can define a ```generateVerificationToken``` method in your provider options if you want to override it: pages/api/auth/[...nextauth].js ```providers: [ EmailProvider({ async generateVerificationToken() { return "ABC123" } })],``` Normalizing the email address â€‹ By default, NextAuth.js will normalize the email address. It treats values as case-insensitive (which is technically not compliant to the RFC 2821 spec , but in practice this causes more problems than it solves, eg. when looking up users by e-mail from databases.) and also removes any secondary email address that was passed in as a comma-separated list. You can apply your own normalization via the ```normalizeIdentifier``` method on the ```EmailProvider``` . The following example shows the default behavior: ``` EmailProvider({ // ... normalizeIdentifier(identifier: string): string { // Get the first two elements only, // separated by `@` from user input. let [local, domain] = identifier.toLowerCase().trim().split("@") // The part before "@" can contain a "," // but we remove it on the domain part domain = domain.split(",")[0] return `${local}@${domain}` // You can also throw an error, which will redirect the user // to the error page with error=EmailSignin in the URL // if (identifier.split("@").length > 2) { // throw new Error("Only one email allowed") // } }, })``` danger Always make sure this returns a single e-mail address, even if multiple ones were passed in.
EVE Online Documentation â€‹ https://developers.eveonline.com/blog/article/sso-to-authenticated-calls Configuration â€‹ https://developers.eveonline.com/ Options â€‹ The EVE Online Provider comes with a set of default options: EVE Online Provider options You can override any of the options to suit your own use case. Example â€‹ ```import EVEOnlineProvider from "next-auth/providers/eveonline";...providers: [ EVEOnlineProvider({ clientId: process.env.EVE_CLIENT_ID, clientSecret: process.env.EVE_CLIENT_SECRET })]...``` When creating your application, make sure to select ```Authentication Only``` as the connection type. ```...options: { jwt: { secret: process.env.JWT_SECRET, }, callbacks: { session: async ({ session, token }) => { session.user.id = token.id; return session; } }}...```
Facebook Documentation â€‹ https://developers.facebook.com/docs/facebook-login/manually-build-a-login-flow/ Configuration â€‹ https://developers.facebook.com/apps/ Options â€‹ The Facebook Provider comes with a set of default options: Facebook Provider options You can override any of the options to suit your own use case. Example â€‹ ```import FacebookProvider from "next-auth/providers/facebook";...providers: [ FacebookProvider({ clientId: process.env.FACEBOOK_CLIENT_ID, clientSecret: process.env.FACEBOOK_CLIENT_SECRET })]...``` tip Production applications cannot use localhost URLs to sign in with Facebook. You need to use a dedicated development application in Facebook to use localhost callback URLs. tip Email address may not be returned for accounts created on mobile.
FACEIT Documentation â€‹ https://cdn.faceit.com/third_party/docs/FACEIT_Connect_3.0.pdf Configuration â€‹ https://developers.faceit.com/apps Grant type: ```Authorization Code``` Scopes to have basic infos (email, nickname, guid and avatar) : ```openid``` , ```email``` , ```profile``` Options â€‹ The FACEIT Provider comes with a set of default options: FACEIT Provider options You can override any of the options to suit your own use case. Example â€‹ ```import FaceItProvider from "next-auth/providers/faceit";...providers: [ FaceItProvider({ clientId: process.env.FACEIT_CLIENT_ID, clientSecret: process.env.FACEIT_CLIENT_SECRET })]...```
Foursquare Documentation â€‹ https://developer.foursquare.com/docs/places-api/authentication/#web-applications Configuration â€‹ https://developer.foursquare.com/ danger Foursquare requires an additional ```apiVersion``` parameter in ```YYYYMMDD``` format , which essentially states "I'm prepared for API changes up to this date". Options â€‹ The Foursquare Provider comes with a set of default options: Foursquare Provider options You can override any of the options to suit your own use case. Example â€‹ ```import FourSquareProvider from "next-auth/providers/foursquare";...providers: [ FourSquareProvider({ clientId: process.env.FOURSQUARE_CLIENT_ID, clientSecret: process.env.FOURSQUARE_CLIENT_SECRET, apiVersion: "YYYYMMDD" })]...```
Freshbooks Documentation â€‹ https://www.freshbooks.com/api/authenticating-with-oauth-2-0-on-the-new-freshbooks-api Configuration â€‹ https://my.freshbooks.com/#/developer Options â€‹ The Freshbooks Provider comes with a set of default options: https://www.freshbooks.com/api/start You can override any of the options to suit your own use case. Example â€‹ ```import FreshbooksProvider from "next-auth/providers/freshbooks";...providers: [ FreshbooksProvider({ clientId: process.env.FRESHBOOKS_CLIENT_ID, clientSecret: process.env.FRESHBOOKS_CLIENT_SECRET, })]...```
FusionAuth Documentation â€‹ https://fusionauth.io/docs/v1/tech/oauth/ Options â€‹ The FusionAuth Provider comes with a set of default options: FusionAuth Provider options You can override any of the options to suit your own use case. Example â€‹ ```import FusionAuthProvider from "next-auth/providers/fusionauth";...providers: [ FusionAuthProvider({ id: "fusionauth", name: "FusionAuth", issuer: process.env.FUSIONAUTH_ISSUER, clientId: process.env.FUSIONAUTH_CLIENT_ID, clientSecret: process.env.FUSIONAUTH_SECRET, tenantId: process.env.FUSIONAUTH_TENANT_ID // Only required if you're using multi-tenancy }),]...``` danger If you're using multi-tenancy, you need to pass in the ```tenantId``` option to apply the proper theme. Instructions â€‹ Configuration â€‹ tip An application can be created at https://your-fusionauth-server-url/admin/application. For more information, follow the FusionAuth 5-minute setup guide . In the OAuth settings for your application, configure the following. Redirect URL https://localhost:3000/api/auth/callback/fusionauth Enabled grants Make sure Authorization Code is enabled. If using JSON Web Tokens, you need to make sure the signing algorithm is RS256, you can create an RS256 key pair by going to Settings, Key Master, generate RSA and choosing SHA-256 as algorithm. After that, go to the JWT settings of your application and select this key as Access Token signing key and Id Token signing key.
GitHub note GitHub returns a field on ```Account``` called ```refresh_token_expires_in``` which is a number. See their docs . Remember to add this field to your database schema, in case if you are using an Adapter . Documentation â€‹ https://developer.github.com/apps/building-oauth-apps/authorizing-oauth-apps Configuration â€‹ https://github.com/settings/apps Options â€‹ The GitHub Provider comes with a set of default options: GitHub Provider options You can override any of the options to suit your own use case. Example â€‹ ```import GitHubProvider from "next-auth/providers/github";...providers: [ GitHubProvider({ clientId: process.env.GITHUB_ID, clientSecret: process.env.GITHUB_SECRET })]...``` danger Only allows one callback URL per Client ID / Client Secret. tip Email address is always returned, even if the user doesn't have a public email address on their profile.
GitLab Documentation â€‹ https://docs.gitlab.com/ee/api/oauth2.html Configuration â€‹ https://gitlab.com/-/profile/applications Options â€‹ The Gitlab Provider comes with a set of default options: Gitlab Provider options You can override any of the options to suit your own use case. Example â€‹ ```import GitlabProvider from "next-auth/providers/gitlab";...providers: [ GitlabProvider({ clientId: process.env.GITLAB_CLIENT_ID, clientSecret: process.env.GITLAB_CLIENT_SECRET })]...``` tip Enable the "read_user" option in scope if you want to save the users email address on sign up.
Google Documentation â€‹ https://developers.google.com/identity/protocols/oauth2 Configuration â€‹ https://console.developers.google.com/apis/credentials The "Authorized redirect URIs" used when creating the credentials must include your full domain and end in the callback path. For example; For production: ```https://{YOUR_DOMAIN}/api/auth/callback/google``` For development: ```http://localhost:3000/api/auth/callback/google``` Options â€‹ The Google Provider comes with a set of default options: Google Provider options You can override any of the options to suit your own use case. Example â€‹ ```import GoogleProvider from "next-auth/providers/google";...providers: [ GoogleProvider({ clientId: process.env.GOOGLE_CLIENT_ID, clientSecret: process.env.GOOGLE_CLIENT_SECRET })]...``` danger Google only provides Refresh Token to an application the first time a user signs in. To force Google to re-issue a Refresh Token, the user needs to remove the application from their account and sign in again: https://myaccount.google.com/permissions Alternatively, you can also pass options in the ```params``` object of ```authorization``` which will force the Refresh Token to always be provided on sign in, however this will ask all users to confirm if they wish to grant your application access every time they sign in. If you need access to the RefreshToken or AccessToken for a Google account and you are not using a database to persist user accounts, this may be something you need to do. ```const options = { ... providers: [ GoogleProvider({ clientId: process.env.GOOGLE_ID, clientSecret: process.env.GOOGLE_SECRET, authorization: { params: { prompt: "consent", access_type: "offline", response_type: "code" } } }) ], ...}``` tip Google also returns a ```email_verified``` boolean property in the OAuth profile. You can use this property to restrict access to people with verified accounts at a particular domain. ```const options = { ... callbacks: { async signIn({ account, profile }) { if (account.provider === "google") { return profile.email_verified && profile.email.endsWith("@example.com") } return true // Do different verification for other providers that don't have `email_verified` }, } ...}```
HubSpot note HubSpot returns a limited amount of information on the token holder (see docs ). One other issue is that the name and profile photo cannot be fetched through API as discussed here . Documentation â€‹ https://developers.hubspot.com/docs/api/oauth-quickstart-guide Configuration â€‹ You need to have an APP in your Developer Account as described at https://developers.hubspot.com/docs/api/developer-tools-overview Options â€‹ The HubSpot Provider comes with a set of default options: HubSpot Provider options You can override any of the options to suit your own use case. Example â€‹ ```import HubspotProvider from "next-auth/providers/hubspot";...providers: [ HubspotProvider({ clientId: process.env.HUBSPOT_CLIENT_ID, clientSecret: process.env.HUBSPOT_CLIENT_SECRET })]...``` danger The Redirect URL under the Auth tab on the HubSpot App Settings page must match the callback url which would be http://localhost:3000/api/auth/callback/hubspot for local development. Only one callback URL per Client ID and Client Secret pair is allowed, so it might be easier to create a new app for local development then fiddle with the url changes.
IdentityServer4 danger IdentityServer4 is discontinued and only releases security updates until November 2022. You should consider an alternative provider. Documentation â€‹ https://identityserver4.readthedocs.io/en/latest/ Options â€‹ The IdentityServer4 Provider comes with a set of default options: IdentityServer4 Provider options You can override any of the options to suit your own use case. Example â€‹ ```import IdentityServer4Provider from "next-auth/providers/identity-server4";...providers: [ IdentityServer4Provider({ id: "identity-server4", name: "IdentityServer4", issuer: process.env.IdentityServer4_Issuer, clientId: process.env.IdentityServer4_CLIENT_ID, clientSecret: process.env.IdentityServer4_CLIENT_SECRET })]...```
Instagram Documentation â€‹ https://developers.facebook.com/docs/instagram-basic-display-api/getting-started Configuration â€‹ https://developers.facebook.com/apps/ Options â€‹ The Instagram Provider comes with a set of default options: Instagram Provider options You can override any of the options to suit your own use case. Example â€‹ ```// pages/api/auth/[...nextauth].jsimport InstagramProvider from "next-auth/providers/instagram";...providers: [ InstagramProvider({ clientId: process.env.INSTAGRAM_CLIENT_ID, clientSecret: process.env.INSTAGRAM_CLIENT_SECRET })]...// pages/index.jsximport { signIn } from "next-auth/react"...<button onClick={() => signIn("instagram")}> Sign in</button>...``` danger Email address is not returned by the Instagram API. tip Instagram display app required callback URL to be configured in your Facebook app and Facebook required you to use https even for localhost! In order to do that, you either need to add an SSL to your localhost or use a proxy such as ngrok .
Kakao Documentation â€‹ https://developers.kakao.com/product/kakaoLogin Configuration â€‹ https://developers.kakao.com/docs/latest/en/kakaologin/common Options â€‹ The Kakao Provider comes with a set of default options: Kakao Provider options You can override any of the options to suit your own use case. Example â€‹ ```import KakaoProvider from "next-auth/providers/kakao";...providers: [ KakaoProvider({ clientId: process.env.KAKAO_CLIENT_ID, clientSecret: process.env.KAKAO_CLIENT_SECRET })]...``` Instructions â€‹ Configuration â€‹ Create a provider and a Kakao application at ```https://developers.kakao.com/console/app``` . In the settings of the app under Kakao Login, activate web app, change consent items and configure callback URL.
Keycloak Documentation â€‹ https://www.keycloak.org/docs/latest/server_admin/#_oidc_clients Configuration â€‹ tip Create an openid-connect client in Keycloak with "confidential" as the "Access Type". Options â€‹ The Keycloak Provider comes with a set of default options: Keycloak Provider options You can override any of the options to suit your own use case. Example â€‹ ```import KeycloakProvider from "next-auth/providers/keycloak";...providers: [ KeycloakProvider({ clientId: process.env.KEYCLOAK_ID, clientSecret: process.env.KEYCLOAK_SECRET, issuer: process.env.KEYCLOAK_ISSUER, })]...``` note ```issuer``` should include the realm â€“ e.g. ```https://my-keycloak-domain.com/realms/My_Realm```
LINE Documentation â€‹ https://developers.line.biz/en/docs/line-login/integrate-line-login/ Configuration â€‹ https://developers.line.biz/console/ Options â€‹ The Line Provider comes with a set of default options: Line Provider options You can override any of the options to suit your own use case. Example â€‹ ```import LineProvider from "next-auth/providers/line";...providers: [ LineProvider({ clientId: process.env.LINE_CLIENT_ID, clientSecret: process.env.LINE_CLIENT_SECRET })]...``` Instructions â€‹ Configuration â€‹ Create a provider and a LINE login channel at ```https://developers.line.biz/console/``` . In the settings of the channel under LINE Login, activate web app and configure the following: Callback URL http://localhost:3000/api/auth/callback/line tip To retrieve email address, you need to apply for Email address permission. Open Line Developer Console , go to your Login Channel. Scroll down bottom to find OpenID Connect -> Email address permission . Click Apply and follow the instruction.
LinkedIn Documentation â€‹ https://docs.microsoft.com/en-us/linkedin/shared/authentication/authorization-code-flow Configuration â€‹ https://www.linkedin.com/developers/apps/ From the Auth tab get the client ID and client secret. On the same tab, add redirect URLs such as http://localhost:3000/api/auth/callback/linkedin so LinkedIn can correctly redirect back to your application. Finally, head over to the Products tab and enable the "Sign In with LinkedIn" product. The LinkedIn team will review and approve your request before you can test it out. Options â€‹ The LinkedIn Provider comes with a set of default options: LinkedIn Provider options You can override any of the options to suit your own use case. Example â€‹ ```import LinkedInProvider from "next-auth/providers/linkedin";...providers: [ LinkedInProvider({ clientId: process.env.LINKEDIN_CLIENT_ID, clientSecret: process.env.LINKEDIN_CLIENT_SECRET })]...```
Mailchimp Documentation â€‹ https://mailchimp.com/developer/marketing/guides/access-user-data-oauth-2/ Configuration â€‹ https://admin.mailchimp.com/account/oauth2/client/ Options â€‹ The Mailchimp Provider comes with a set of default options: Mailchimp Provider options You can override any of the options to suit your own use case. Example â€‹ ```import MailchimpProvider from "next-auth/providers/mailchimp";...providers: [ MailchimpProvider({ clientId: process.env.MAILCHIMP_CLIENT_ID, clientSecret: process.env.MAILCHIMP_CLIENT_SECRET })]...```
Mail.ru Documentation â€‹ https://o2.mail.ru/docs Configuration â€‹ https://o2.mail.ru/app/ Options â€‹ The Mail.ru Provider comes with a set of default options: Mail.ru Provider options You can override any of the options to suit your own use case. Example â€‹ ```import MailRuProvider from "next-auth/providers/mailru";...providers: [ MailRuProvider({ clientId: process.env.MAILRU_CLIENT_ID, clientSecret: process.env.MAILRU_CLIENT_SECRET })]...```
Medium Documentation â€‹ https://github.com/Medium/medium-api-docs Configuration â€‹ https://medium.com/me/applications Options â€‹ The Medium Provider comes with a set of default options: Medium Provider options You can override any of the options to suit your own use case. Example â€‹ ```import MediumProvider from "next-auth/providers/medium";...providers: [ MediumProvider({ clientId: process.env.MEDIUM_CLIENT_ID, clientSecret: process.env.MEDIUM_CLIENT_SECRET })}...``` danger Email address is not returned by the Medium API.
Naver Documentation â€‹ https://developers.naver.com/docs/login/overview/overview.md Configuration â€‹ https://developers.naver.com/docs/login/api/api.md Options â€‹ The Naver Provider comes with a set of default options: Naver Provider options You can override any of the options to suit your own use case. Example â€‹ ```import NaverProvider from "next-auth/providers/naver";...providers: [ NaverProvider({ clientId: process.env.NAVER_CLIENT_ID, clientSecret: process.env.NAVER_CLIENT_SECRET })]...```
Netlify Documentation â€‹ https://www.netlify.com/blog/2016/10/10/integrating-with-netlify-oauth2/ Configuration â€‹ https://github.com/netlify/netlify-oauth-example Options â€‹ The Netlify Provider comes with a set of default options: Netlify Provider options You can override any of the options to suit your own use case. Example â€‹ ```import NetlifyProvider from "next-auth/providers/netlify";...providers: [ NetlifyProvider({ clientId: process.env.NETLIFY_CLIENT_ID, clientSecret: process.env.NETLIFY_CLIENT_SECRET })]...```
Okta Documentation â€‹ https://developer.okta.com/docs/reference/api/oidc Options â€‹ The Okta Provider comes with a set of default options: Okta Provider options You can override any of the options to suit your own use case. Example â€‹ ```import OktaProvider from "next-auth/providers/okta";...providers: [ OktaProvider({ clientId: process.env.OKTA_CLIENT_ID, clientSecret: process.env.OKTA_CLIENT_SECRET, issuer: process.env.OKTA_ISSUER })]...```
OneLogin Documentation â€‹ https://developers.onelogin.com/openid-connect Configuration â€‹ https://developers.onelogin.com/openid-connect/connect-to-onelogin Options â€‹ The OneLogin Provider comes with a set of default options: OneLogin Provider options You can override any of the options to suit your own use case. Example â€‹ ```import OneLoginProvider from "next-auth/providers/onelogin";...providers: [ OneLoginProvider({ clientId: process.env.ONELOGIN_CLIENT_ID, clientSecret: process.env.ONELOGIN_CLIENT_SECRET, issuer: process.env.ONELOGIN_ISSUER })]...```
Osso Documentation â€‹ Osso is an open source service that handles SAML authentication against Identity Providers, normalizes profiles, and makes those profiles available to you in an OAuth 2.0 code grant flow. If you don't yet have an Osso instance, you can use Osso's Demo App for your testing purposes. For documentation on deploying an Osso instance, see https://ossoapp.com/docs/deploy/overview/ Configuration â€‹ You can configure your OAuth Clients on your Osso Admin UI, i.e. https://demo.ossoapp.com/admin/config - you'll need to get a Client ID and Secret and allow-list your redirect URIs. SAML SSO differs a bit from OAuth - for every tenant who wants to sign in to your application using SAML, you and your customer need to perform a multi-step configuration in Osso's Admin UI and the admin dashboard of the tenant's Identity Provider. Osso provides documentation for providers like Okta and OneLogin, cloud-based IDPs who also offer a developer account that's useful for testing. Osso also provides a Mock IDP that you can use for testing without needing to sign up for an Identity Provider service. See Osso's complete configuration and testing documentation at https://ossoapp.com/docs/configure/overview Options â€‹ The Osso Provider comes with a set of default options: Osso Provider options You can override any of the options to suit your own use case. Example â€‹ A full example application is available at https://github.com/enterprise-oss/osso-next-auth-example and https://nextjs-demo.ossoapp.com ```import OssoProvider from "next-auth/providers/osso";...providers: [ OssoProvider({ clientId: process.env.OSSO_CLIENT_ID, clientSecret: process.env.OSSO_CLIENT_SECRET, issuer: process.env.OSSO_ISSUER })}...``` note ```issuer``` should be the fully qualified domain â€“ e.g. ```demo.ossoapp.com```
Osu! Documentation â€‹ https://osu.ppy.sh/docs/index.html#authentication Configuration â€‹ https://osu.ppy.sh/home/account/edit#new-oauth-application Options â€‹ The Osu Provider comes with a set of default options: Osu Provider options You can override any of the options to suit your own use case. note Osu! does not provide a user email! Example â€‹ ```import OsuProvider from "next-auth/providers/osu";...providers: [ OsuProvider({ clientId: process.env.OSU_CLIENT_ID, clientSecret: process.env.OSU_CLIENT_SECRET })]...```
Patreon Documentation â€‹ https://docs.patreon.com/#apiv2-oauth Configuration â€‹ tip Create a API v2 client on Patreon Platform Options â€‹ The Patreon Provider comes with a set of default options: Patreon Provider options You can override any of the options to suit your own use case. Example â€‹ ```import PatreonProvider from "next-auth/providers/patreon";...providers: [ PatreonProvider({ clientId: process.env.PATREON_ID, clientSecret: process.env.PATREON_SECRET, })]...``` note Make sure you use the scopes defined in ApiV2
Pinterest Documentation â€‹ https://developers.pinterest.com/docs/getting-started/authentication/ Configuration â€‹ https://developers.pinterest.com/apps/ Options â€‹ The Pinterest Provider comes with a set of default options: Pinterest Provider options You can override any of the options to suit your own use case. Example â€‹ ```import PinterestProvider from "next-auth/providers/pinterest"...providers: [ PinterestProvider({ clientId: process.env.PINTEREST_ID, clientSecret: process.env.PINTEREST_SECRET })]...:::tipTo use in production, make sure the app has standard API access and not trial access:::```
Pipedrive Documentation â€‹ https://pipedrive.readme.io/docs/marketplace-oauth-authorization Options â€‹ The Pipedrive Provider comes with a set of default options: Pipedrive Provider options You can override any of the options to suit your own use case. Example â€‹ ```import PipedriveProvider from "next-auth/providers/pipedrive";...providers: [ PipedriveProvider({ clientId: process.env.PIPEDRIVE_CLIENT_ID, clientSecret: process.env.PIPEDRIVE_CLIENT_SECRET, })]...```
Reddit Documentation â€‹ https://www.reddit.com/dev/api/ App Configuration â€‹ Visit https://www.reddit.com/prefs/apps/ and create a new web app Provide a name for your web app Provide a redirect uri ending with ```/api/auth/callback/reddit``` : All other fields are optional Click the "create app" button Options â€‹ The Reddit Provider comes with a set of default options: Reddit Provider options You can override any of the options to suit your own use case. Example â€‹ ```import RedditProvider from "next-auth/providers/reddit";...providers: [ RedditProvider({ clientId: process.env.REDDIT_CLIENT_ID, clientSecret: process.env.REDDIT_CLIENT_SECRET })]...``` danger Reddit requires authorization every time you go through their page. danger Only allows one callback URL per Client ID / Client Secret. tip This Provider template only has a one hour access token to it and only has the "identity" scope. If you want to get a refresh token as well you must follow this: ```providers: [ RedditProvider({ clientId: process.env.REDDIT_CLIENT_ID, clientSecret: process.env.REDDIT_CLIENT_SECRET, authorization: { params: { duration: 'permanent', }, }, }),]```
Salesforce Documentation â€‹ https://help.salesforce.com/articleView?id=remoteaccess_authenticate.htm&type=5 Options â€‹ The Salesforce Provider comes with a set of default options: Salesforce Provider options You can override any of the options to suit your own use case. Example â€‹ ```import SalesforceProvider from "next-auth/providers/salesforce";...providers: [ SalesforceProvider({ clientId: process.env.SALESFORCE_CLIENT_ID, clientSecret: process.env.SALESFORCE_CLIENT_SECRET, })]...```
Slack Documentation â€‹ https://api.slack.com/authentication https://api.slack.com/docs/sign-in-with-slack Configuration â€‹ https://api.slack.com/apps danger Slack requires that the redirect URL of your app uses ```https``` , even for local development. An easy workaround for this is using a service like ```ngrok``` that creates a secure tunnel to your app, using ```https``` . Remember to set the url as ```NEXTAUTH_URL``` as well. Options â€‹ The Slack Provider comes with a set of default options: Slack Provider options You can override any of the options to suit your own use case. Example â€‹ ```import SlackProvider from "next-auth/providers/slack";...providers: [ SlackProvider({ clientId: process.env.SLACK_CLIENT_ID, clientSecret: process.env.SLACK_CLIENT_SECRET })]...```
Spotify Documentation â€‹ https://developer.spotify.com/documentation/general/guides/authorization-guide Configuration â€‹ https://developer.spotify.com/dashboard/applications Options â€‹ The Spotify Provider comes with a set of default options: Spotify Provider options You can override any of the options to suit your own use case. Example â€‹ ```import SpotifyProvider from "next-auth/providers/spotify";...providers: [ SpotifyProvider({ clientId: process.env.SPOTIFY_CLIENT_ID, clientSecret: process.env.SPOTIFY_CLIENT_SECRET })]...```
Strava Documentation â€‹ http://developers.strava.com/docs/reference/ Options â€‹ The Strava Provider comes with a set of default options: Strava Provider options You can override any of the options to suit your own use case. Ensure the redirect_uri configuration fits your needs accordingly. Example â€‹ ```import StravaProvider from "next-auth/providers/strava";...providers: [ StravaProvider({ clientId: process.env.STRAVA_CLIENT_ID, clientSecret: process.env.STRAVA_CLIENT_SECRET, })]...```
Todoist Documentation â€‹ https://developer.todoist.com/guides/#oauth Configuration â€‹ https://developer.todoist.com/appconsole.html Options â€‹ The Todoist Provider comes with a set of default options: Todoist Provider options You can override any of the options to suit your own use case. Example â€‹ ```import TodoistProvider from "next-auth/providers/todoist";...providers: [ TodoistProvider({ clientId: process.env.TODOIST_ID, clientSecret: process.env.TODOIST_SECRET })]...```
Trakt Documentation â€‹ https://trakt.docs.apiary.io/#reference/authentication-oauth Configuration â€‹ If you're using the api in production by calling api.trakt.tv . Follow the example below. If you wish to develop on Trakt's sandbox environment by calling api-staging.trakt.tv . Use the default options with the changed the URLs. Start by creating an OAuth app on Trakt for production or development . Then set the Client ID and Client Secret as ```TRAKT_ID``` and ```TRAKT_SECRET``` in ```.env``` . Options â€‹ The Trakt Provider comes with a set of default options: Trakt Provider options You can override any of the options to suit your own use case. Example â€‹ ```providers: [ TraktProvider({ clientId: process.env.TRAKT_ID, clientSecret: process.env.TRAKT_SECRET, }),]``` danger Trakt does not allow hotlinking images. Even the authenticated user's profie picture. danger Trakt does not supply the authenticated user's email.
Twitch Documentation â€‹ https://dev.twitch.tv/docs/authentication Configuration â€‹ https://dev.twitch.tv/console/apps Add the following redirect URL into the console ```http://<your-next-app-url>/api/auth/callback/twitch``` Options â€‹ The Twitch Provider comes with a set of default options: Twitch Provider options You can override any of the options to suit your own use case. Example â€‹ ```import TwitchProvider from "next-auth/providers/twitch";...providers: [ TwitchProvider({ clientId: process.env.TWITCH_CLIENT_ID, clientSecret: process.env.TWITCH_CLIENT_SECRET })]...```
Twitter note Twitter is currently the only built-in provider using the OAuth 1.0 spec. This means that you won't receive an ```access_token``` or ```refresh_token``` , but an ```oauth_token``` and ```oauth_token_secret``` respectively. Remember to add these to your database schema, in case if you are using an Adapter . Documentation â€‹ https://developer.twitter.com Configuration â€‹ https://developer.twitter.com/en/apps Options â€‹ The Twitter Provider comes with a set of default options: Twitter Provider options You can override any of the options to suit your own use case. Example â€‹ ```import TwitterProvider from "next-auth/providers/twitter";...providers: [ TwitterProvider({ clientId: process.env.TWITTER_CLIENT_ID, clientSecret: process.env.TWITTER_CLIENT_SECRET })]...``` tip You must enable the "Request email address from users" option in your app permissions if you want to obtain the users email address. OAuth 2.0 â€‹ Twitter supports OAuth 2, which is currently opt-in. To enable it, simply add ```version: "2.0"``` to your Provider configuration: ```TwitterProvider({ clientId: process.env.TWITTER_ID, clientSecret: process.env.TWITTER_SECRET, version: "2.0", // opt-in to Twitter OAuth 2.0})``` Keep in mind that although this change is easy, it changes how and with which of Twitter APIs you can interact with. Read the official Twitter OAuth 2 documentation for more details. note Email is currently not supported by Twitter OAuth 2.0.
United Effects Documentation â€‹ https://docs.unitedeffects.com/integrations/nextauthjs Configuration â€‹ https://core.unitedeffects.com Options â€‹ The United Effects Provider comes with a set of default options: United Effects Provider options You can override any of the options to suit your own use case. Example â€‹ ```import UnitedEffectsProvider from "next-auth/providers/united-effects";...providers: [ UnitedEffectsProvider({ clientId: process.env.UNITED_EFFECTS_CLIENT_ID, clientSecret: process.env.UNITED_EFFECTS_CLIENT_SECRET, issuer: process.env.UNITED_EFFECTS_ISSUER })]...``` note ```issuer``` should be the fully qualified URL including your Auth Group ID â€“ e.g. ```https://auth.unitedeffects.com/YQpbQV5dbW-224dCovz-3``` danger The United Effects API does not return the user name or image by design, so this provider will return null for both. United Effects prioritizes user personal information security above all and has built a secured profile access request system separate from the provider API.
VK Documentation â€‹ https://vk.com/dev/first_guide Configuration â€‹ https://vk.com/apps?act=manage Options â€‹ The VK Provider comes with a set of default options: VK Provider options You can override any of the options to suit your own use case. Example â€‹ ```import VkProvider from "next-auth/providers/vk";...providers: [ VkProvider({ clientId: process.env.VK_CLIENT_ID, clientSecret: process.env.VK_CLIENT_SECRET })]...``` note By default the provider uses ```5.131``` version of the API. See https://vk.com/dev/versions for more info. If you want to use a different version, you can pass it to provider's options object: ```// pages/api/auth/[...nextauth].jsconst apiVersion = "5.131"...providers: [ VkProvider({ accessTokenUrl: `https://oauth.vk.com/access_token?v=${apiVersion}`, requestTokenUrl: `https://oauth.vk.com/access_token?v=${apiVersion}`, authorizationUrl: `https://oauth.vk.com/authorize?response_type=code&v=${apiVersion}`, profileUrl: `https://api.vk.com/method/users.get?fields=photo_100&v=${apiVersion}`, })]...```
Wikimedia Documentation â€‹ https://www.mediawiki.org/wiki/Extension:OAuth This provider also supports all Wikimedia projects: Wikipedia Wikidata Wikibooks Wiktionary etc.. Please be aware that Wikimedia accounts do not have to have an associated email address. So you may want to add check if the user has an email address before allowing them to login. Configuration â€‹ Go to and accept the Consumer Registration doc: https://meta.wikimedia.org/wiki/Special:OAuthConsumerRegistration Request a new OAuth 2.0 consumer to get the ```clientId``` and ```clientSecret``` : https://meta.wikimedia.org/wiki/Special:OAuthConsumerRegistration/propose/oauth2 2a. Add the following redirect URL into the console ```http://<your-next-app-url>/api/auth/callback/wikimedia``` 2b. Do not check the box next to ```This consumer is only for [your username]``` 2c. Unless you explicitly need a larger scope, feel free to select the radio button labelled ```User identity verification only - no ability to read pages or act on the users behalf.``` After registration, you can initally test your application only with your own Wikimedia account. You may have to wait several days for the application to be approved for it to be used by everyone. Options â€‹ The Wikimedia Provider comes with a set of default options: Wikimedia Provider options You can override any of the options to suit your own use case. Example â€‹ ```import WikimediaProvider from "next-auth/providers/wikimedia";...providers: [ WikimediaProvider({ clientId: process.env.WIKIMEDIA_CLIENT_ID, clientSecret: process.env.WIKIMEDIA_CLIENT_SECRET })]...```
WordPress.com Documentation â€‹ https://developer.wordpress.com/docs/oauth2/ Configuration â€‹ https://developer.wordpress.com/apps/ Options â€‹ The Wordpress Provider comes with a set of default options: Wordpress Provider options You can override any of the options to suit your own use case. Example â€‹ ```import WordpressProvider from "next-auth/providers/wordpress";...providers: [ WordpressProvider({ clientId: process.env.WORDPRESS_CLIENT_ID, clientSecret: process.env.WORDPRESS_CLIENT_SECRET })}...``` tip Register your application to obtain Client ID and Client Secret at https://developer.wordpress.com/apps/ Select Type as Web and set Redirect URL to ```http://example.com/api/auth/callback/wordpress``` where example.com is your site domain.
WorkOS Documentation â€‹ https://workos.com/docs/sso/guide Configuration â€‹ https://dashboard.workos.com Options â€‹ The WorkOS Provider comes with a set of default options: WorkOS Provider options You can override any of the options to suit your own use case. Example â€‹ ```import WorkOSProvider from "next-auth/providers/workos";...providers: [ WorkOSProvider({ clientId: process.env.WORKOS_CLIENT_ID, clientSecret: process.env.WORKOS_API_KEY, }),],...``` WorkOS is not an identity provider itself, but, rather, a bridge to multiple single sign-on (SSO) providers. As a result, we need to make some additional changes to authenticate users using WorkOS. In order to sign a user in using WorkOS, we need to specify which WorkOS Connection to use. A common way to do this is to collect the user's email address and extract the domain. This can be done using a custom login page. To add a custom login page, you can use the ```pages``` option: pages/api/auth/[...nextauth].js ```... pages: { signIn: "/auth/signin", }``` We can then add a custom login page that displays an input where the user can enter their email address. We then extract the domain from the user's email address and pass it to the ```authorizationParams``` parameter on the ```signIn``` function: pages/auth/signin.js ```import { useState } from "react"import { getProviders, signIn } from "next-auth/react"export default function SignIn({ providers }) { const [email, setEmail] = useState("") return ( <> {Object.values(providers).map((provider) => { if (provider.id === "workos") { return ( <div key={provider.id}> <input type="email" value={email} placeholder="Email" onChange={(event) => setEmail(event.target.value)} /> <button onClick={() => signIn(provider.id, undefined, { domain: email.split("@")[1], }) } > Sign in with SSO </button> </div> ) } return ( <div key={provider.id}> <button onClick={() => signIn(provider.id)}> Sign in with {provider.name} </button> </div> ) })} </> )}export async function getServerSideProps(context) { const providers = await getProviders() return { props: { providers }, }}```
Yandex Documentation â€‹ https://tech.yandex.com/oauth/doc/dg/concepts/about-docpage/ Configuration â€‹ https://oauth.yandex.com/client/new Options â€‹ The Yandex Provider comes with a set of default options: Yandex Provider options You can override any of the options to suit your own use case. Example â€‹ ```import YandexProvider from "next-auth/providers/yandex";...providers: [ YandexProvider({ clientId: process.env.YANDEX_CLIENT_ID, clientSecret: process.env.YANDEX_CLIENT_SECRET })]...```
Zitadel Documentation â€‹ https://docs.zitadel.com/docs/apis/openidoauth/endpoints Configuration â€‹ https://docs.zitadel.com/docs/guides/integrate/oauth-recommended-flows The Redirect URIs used when creating the credentials must include your full domain and end in the callback path. For example: For production: ```https://{YOUR_DOMAIN}/api/auth/callback/zitadel``` For development: ```http://localhost:3000/api/auth/callback/zitadel``` Make sure to enable dev mode in ZITADEL console to allow redirects for local development. Options â€‹ The ZITADEL Provider comes with a set of default options: ZITADEL Provider options You can override any of the options to suit your own use case. Example â€‹ ```import ZitadelProvider from "next-auth/providers/zitadel";...providers: [ ZitadelProvider({ issuer: process.env.ZITADEL_ISSUER, clientId: process.env.ZITADEL_CLIENT_ID, clientSecret: process.env.ZITADEL_CLIENT_SECRET, })]...``` If you need access to ZITADEL APIs or need additional information, make sure to add the corresponding scopes. To get the full list of supported claims take a look here . ```const options = { ... providers: [ ZitadelProvider({ clientId: process.env.ZITADEL_CLIENT_ID, authorization: { params: { scope: `openid email profile urn:zitadel:iam:org:project:id:${process.env.ZITADEL_PROJECT_ID}:aud` } } }) ], ...}``` ::: tip ZITADEL also returns a ```email_verified``` boolean property in the profile. You can use this property to restrict access to people with verified accounts. ```const options = { ... callbacks: { async signIn({ account, profile }) { if (account.provider === "zitadel") { return profile.email_verified; } return true; // Do different verification for other providers that don't have `email_verified` }, } ...}```
Zoho Documentation â€‹ https://www.zoho.com/accounts/protocol/oauth/web-server-applications.html Configuration â€‹ https://api-console.zoho.com/ Options â€‹ The Zoho Provider comes with a set of default options: Zoho Provider options You can override any of the options to suit your own use case. Example â€‹ ```import ZohoProvider from "next-auth/providers/zoho";...providers: [ ZohoProvider({ clientId: process.env.ZOHO_CLIENT_ID, clientSecret: process.env.ZOHO_CLIENT_SECRET })]...```
Zoom Documentation â€‹ https://marketplace.zoom.us/docs/guides/auth/oauth Configuration â€‹ https://marketplace.zoom.us Options â€‹ The Zoom Provider comes with a set of default options: Zoom Provider options You can override any of the options to suit your own use case. Example â€‹ ```import ZoomProvider from "next-auth/providers/zoom"...providers: [ ZoomProvider({ clientId: process.env.ZOOM_CLIENT_ID, clientSecret: process.env.ZOOM_CLIENT_SECRET })}...```
Adapters Visit the authjs.dev page for the up-to-date documentation. Dgraph DynamoDB Fauna Firebase MongoDB Prisma TypeORM MikroORM neo4j PouchDB Sequelize Supabase Upstash Redis Xata
Warnings This is a list of warning output from NextAuth.js. All warnings indicate things which you should take a look at, but do not inhibit normal operation. Client â€‹ NEXTAUTH_URL â€‹ Environment variable ```NEXTAUTH_URL``` missing. Please set it in your ```.env``` file. note On Vercel deployments, we will read the ```VERCEL_URL``` environment variable, so you won't need to define ```NEXTAUTH_URL``` . Server â€‹ These warnings are displayed on the terminal. NO_SECRET â€‹ In development, we generate a ```secret``` based on your configuration for convenience. This is volatile and will throw an error in production. Read more TWITTER_OAUTH_2_BETA â€‹ Twitter OAuth 2.0 is currently in beta as certain changes might still be necessary. This is not covered by semver. See the docs https://next-auth.js.org/providers/twitter#oauth-2 EXPERIMENTAL_API â€‹ Some APIs are still experimental; they may be changed or removed in the future. Use at your own risk. DEBUG_ENABLED â€‹ You have enabled the ```debug``` option. It is meant for development only, to help you catch issues in your authentication flow and you should consider removing this option when deploying to production. One way of only allowing debugging while not in production is to set ```debug: process.env.NODE_ENV !== "production"``` , so you can commit this without needing to change the value. If you want to log debug messages during production anyway, we recommend setting the ```logger``` option with proper sanitization of potentially sensitive user information. Adapter â€‹ ADAPTER_TYPEORM_UPDATING_ENTITIES â€‹ This warning occurs when typeorm finds that the provided entities differ from the database entities. By default while not in ```production``` the typeorm adapter will always synchronize changes made to the entities codefiles. Disable this warning by setting ```synchronize: false``` in your typeorm config Example: /pages/api/auth/[...nextauth].js ```adapter: TypeORMLegacyAdapter({ type: 'mysql', username: process.env.DATABASE_USERNAME, password: process.env.DATABASE_PASSWORD, host: process.env.DATABASE_HOST, database: process.env.DATABASE_DB, synchronize: false}),```
Errors This is a list of errors output from NextAuth.js. All errors indicate an unexpected problem, you should not expect to see errors. If you are seeing any of these errors in the console, something is wrong. Client â€‹ These errors are returned from the client. As the client is Universal JavaScript (or "Isomorphic JavaScript") it can be run on the client or server, so these errors can occur both in the terminal and in the browser console. CLIENT_SESSION_ERROR â€‹ This error occurs when the ```SessionProvider``` Context has a problem fetching session data. CLIENT_FETCH_ERROR â€‹ If you see ```CLIENT_FETCH_ERROR``` make sure you have configured the ```NEXTAUTH_URL``` environment variable. Server â€‹ These errors are displayed on the terminal. OAuth â€‹ OAUTH_GET_ACCESS_TOKEN_ERROR â€‹ This occurs when there was an error in the POST request to the OAuth provider and we were not able to retrieve the access token. Please double check your provider settings. OAUTH_V1_GET_ACCESS_TOKEN_ERROR â€‹ This error is explicitly related to older OAuth v1.x providers, if you are using one of these, please double check all available settings. OAUTH_GET_PROFILE_ERROR â€‹ N/A OAUTH_PARSE_PROFILE_ERROR â€‹ This error is a result of either a problem with the provider response or the user canceling the action with the provider, unfortunately, we can't discern which with the information we have. This error should also log the exception and available ```profileData``` to further aid debugging. OAUTH_CALLBACK_HANDLER_ERROR â€‹ This error will occur when there was an issue parsing the JSON request body, for example. There should also be further details logged when this occurs, such as the error is thrown, and the request body itself to aid in debugging. Signin / Callback â€‹ SIGNIN_OAUTH_ERROR â€‹ This error occurs during the redirection to the authorization URL of the OAuth provider. Possible causes: Cookie handling Either PKCE code verifier or the generation of the CSRF token hash in the internal state failed. If set, check your ```cookies``` configuration , and make sure the browser is not blocking/restricting cookies. OAuth misconfiguration Please check your OAuth provider and make sure your URLs and other options are correctly set. If you are using an OAuth v1 provider, check your OAuth v1 provider settings, especially the OAuth token and OAuth token secret. ```openid-client``` version mismatch If you are seeing ```expected 200 OK with body but no body was returned``` , it might have happened due to ```openid-client``` (which is a dependency we rely on) node version mismatch. For instance, ```openid-client``` requires ```>=14.2.0``` for ```lts/fermium``` and has similar limits for the other versions. For the full list of the compatible node versions please see package.json . OAUTH_CALLBACK_ERROR â€‹ This can occur during the handling of the callback if the ```code_verifier``` cookie was not found or an invalid state was returned from the OAuth provider. SIGNIN_EMAIL_ERROR â€‹ This error can occur when a user tries to sign in via an email link; for example, if the email token could not be generated or the verification request failed. Please double check your email settings. CALLBACK_EMAIL_ERROR â€‹ This can occur during the email callback process. Specifically, if there was an error signing the user in via email, encoding the jwt, etc. Please double check your Email settings. EMAIL_REQUIRES_ADAPTER_ERROR â€‹ The Email authentication provider can only be used if a database is configured. This is required to store the verification token. Please see the email provider for more details. CALLBACK_CREDENTIALS_JWT_ERROR â€‹ The Credentials Provider can only be used if JSON Web Tokens are used for sessions. JSON Web Tokens are used for Sessions by default if you have not specified a database. However, if you are using a database, then Database Sessions are enabled by default and you need to explicitly enable JWT Sessions to use the Credentials Provider. If you are using a Credentials Provider, NextAuth.js will not persist users or sessions in a database - user accounts used with the Credentials Provider must be created and managed outside of NextAuth.js. In most cases it does not make sense to specify a database in NextAuth.js options and support a Credentials Provider. CALLBACK_CREDENTIALS_HANDLER_ERROR â€‹ This error occurs when there was no ```authorize()``` handler defined on the credential authentication provider. PKCE_ERROR â€‹ The provider you tried to use failed when setting PKCE or Proof Key for Code Exchange . The ```code_verifier``` is saved in a cookie called (by default) ```__Secure-next-auth.pkce.code_verifier``` which expires after 15 minutes. Check if ```cookies.pkceCodeVerifier``` is configured correctly. The default ```code_challenge_method``` is ```"S256"``` . This is currently not configurable to ```"plain"``` , as per RFC7636 : If the client is capable of using "S256", it MUST use "S256", as S256" is Mandatory To Implement (MTI) on the server. INVALID_CALLBACK_URL_ERROR â€‹ The ```callbackUrl``` provided was either invalid or not defined. See specifying a ```callbackUrl``` for more information. Session Handling â€‹ JWT_SESSION_ERROR â€‹ JWTKeySupport: the key does not support HS512 verify algorithm The algorithm used for generating your key isn't listed as supported. You can generate a HS512 key using ``` jose newkey -s 512 -t oct -a HS512``` SESSION_ERROR â€‹ Signout â€‹ SIGNOUT_ERROR â€‹ This error occurs when there was an issue deleting the session from the database, for example. Configuration â€‹ MISSING_NEXTAUTH_API_ROUTE_ERROR â€‹ This error happens when ```[...nextauth].js``` file is not found inside ```pages/api/auth``` . Make sure the file is there and the filename is written correctly. NO_SECRET â€‹ In production, we expect you to define a ```secret``` property in your configuration. In development, this is shown as a warning for convenience. Read more AUTH_ON_ERROR_PAGE_ERROR â€‹ You have a custom error page defined that was rendered due to an error, but the page also required authentication. To avoid an infinite redirect loop, NextAuth.js bailed out and rendered its default error page instead. If you are using a Middleware, make sure you include the same ```pages``` configuration in your ```middleware.ts``` and ```[...nextauth].ts``` files. Or use the ```matcher``` option to only require authentication for certain sites (and exclude your custom error page). If you do not use a Middleware, make sure you don't try redirecting the user to the sign-in page when hitting your custom error page. Useful links: https://next-auth.js.org/configuration/nextjs#pages https://next-auth.js.org/configuration/pages https://nextjs.org/docs/advanced-features/middleware#matcher
Deployment Deploying NextAuth.js only requires a few steps. It can be run anywhere a Next.js application can. Therefore, in a default configuration using only JWT session strategy, i.e. without a database, you will only need these few things in addition to your application: NextAuth.js environment variables ```NEXTAUTH_SECRET``` ```NEXTAUTH_URL``` NextAuth.js API Route and its configuration ( ```/pages/api/auth/[...nextauth].js``` ). OAuth Provider ```clientId``` / ```clientSecret``` Deploying a modern JavaScript application using NextAuth.js consists of making sure your environment variables are set correctly as well as the configuration in the NextAuth.js API route is setup, as well as any configuration (like Callback URLs, etc.) are correctly done in your OAuth provider(s) themselves. See below for more detailed provider settings. Vercel â€‹ Make sure to expose the Vercel System Environment Variables in your project settings. Create a ```NEXTAUTH_SECRET``` environment variable for all environments. You can use ```openssl rand -base64 32``` or https://generate-secret.vercel.app/32 to generate a random value. You do not need the ```NEXTAUTH_URL``` environment variable in Vercel. Add your provider's client ID and client secret to environment variables. (Skip this step if not using an OAuth Provider ) Deploy! Example repository: https://github.com/nextauthjs/next-auth-example A few notes about deploying to Vercel. The environment variables are read server-side, so you do not need to prefix them with ```NEXT_PUBLIC_``` . When deploying here, you do not need to explicitly set the ```NEXTAUTH_URL``` environment variable. With other providers you will need to also set this environment variable. Securing a preview deployment â€‹ Securing a preview deployment (with an OAuth provider) comes with some critical obstacles. Most OAuth providers only allow a single redirect/callback URL, or at least a set of full static URLs. Meaning you cannot set the value before publishing the site and you cannot use wildcard subdomains in the callback URL settings of your OAuth provider. Here are a few ways you can still use NextAuth.js to secure your Preview Deployments. Using the Credentials Provider â€‹ You could check in your ```/pages/api/auth/[...nextauth].js``` API route / configuration file to see if you're currently in a Vercel preview environment, and if so, enable a simple "credential provider", meaning username/password. Vercel offers a few built-in system environment variables which you could check against, like ```VERCEL_ENV``` . This would allow you to use this basic, for testing only, authentication strategy in your preview deployments. Some things to be aware of here, include: Do not let this potential testing-only user have access to any critical data If possible, maybe do not even connect this preview deployment to your production database Example â€‹ /pages/api/auth/[...nextauth].js ```import NextAuth from "next-auth"import GoogleProvider from "next-auth/providers/google"import CredentialsProvider from "next-auth/providers/credentials"export default NextAuth({ providers: [ process.env.VERCEL_ENV === "preview" ? CredentialsProvider({ name: "Credentials", credentials: { username: { label: "Username", type: "text", placeholder: "jsmith", }, password: { label: "Password", type: "password" }, }, async authorize() { return { id: 1, name: "J Smith", email: "jsmith@example.com", image: "https://i.pravatar.cc/150?u=jsmith@example.com", } }, }) : GoogleProvider({ clientId: process.env.GOOGLE_ID, clientSecret: process.env.GOOGLE_SECRET, }), ],})``` Using the branch based preview URL â€‹ Preview deployments at Vercel are often available via multiple URLs. For example, PR's merged to ```master``` or ```main``` , will be available via commit and PR specific preview URLs, but also the branch specific preview URLs. This branch specific URL will obviously not change as long as you work with that same branch. Therefore, you could add to your OAuth provider your ```{project}-git-main-{user}.vercel.app``` preview URL. As this will stay constant for that branch, you can reuse that preview deployment / URL for testing any authentication related deployments. Netlify â€‹ Netlify is very similar to Vercel in that you can deploy a Next.js project without almost any extra work. In order to setup NextAuth.js correctly here, you will want to make sure you add your ```NEXTAUTH_SECRET``` environment variable in the project settings. If you are using the Essential Next.js Build Plugin within your project, you do not need to set the ```NEXTAUTH_URL``` environment variable as it is set automatically as part of the build process. Netlify also exposes some system environment variables from which you can check which ```NODE_ENV``` you are currently in and much more. After this, just make sure you either have your OAuth provider setup correctly with ```clientId``` / ```clientSecret``` 's and callback URLs.
Guides We have internal guides in three levels of difficulty. Basics Fullstack Testing If you can't find what you're looking for here, maybe take a look at our third-party tutorials page.
Basics Securing pages and API routes â€‹ How to restrict access to pages and API routes. Usage with class components â€‹ How to use ```useSession()``` hook with class components.
Fullstack Refresh Token Rotation â€‹ How to implement refresh token rotation. LDAP Authentication â€‹ How to use the Credentials Provider to authenticate against an LDAP database. This approach can be used to authenticate existing user accounts against any backend. Adding HTTP(S) Proxy Support â€‹ Add support for HTTP/HTTPS Proxy support to ```openid-client``` in order to use NextAuth.js behind a corporate proxy or other locked down network. Using the Email Provider behind Corporate Email Scanning Services â€‹ An internal tutorial on modifying the catch-all API Route to gracefully handle ```HEAD``` requests. Database â€‹ Custom models with TypeORM â€‹ How to use models with custom properties using the TypeORM adapter. Creating a database adapter â€‹ How to create a custom adapter, to use any database to fetch and store user / account data. Adding role based login to database session strategy â€‹ Implement a role based login system by adding a custom session callback.
Testing Testing with Cypress â€‹ How to write tests using Cypress.

</p>>

</body>
</html>